<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ThreadPoolExcutor源码分析 | Welcome to Jeff&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ThreadPoolExecutor的状态和属性ThreadPoolExecutor线程池有5个状态，分别是：  RUNNING：可以接受新的任务，也可以处理阻塞队列里的任务 SHUTDOWN：不接受新的任务，但是可以处理阻塞队列里的任务 STOP：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务 TIDYING：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadPoolExcutor源码分析">
<meta property="og:url" content="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Welcome to Jeff&#39;s blog">
<meta property="og:description" content="ThreadPoolExecutor的状态和属性ThreadPoolExecutor线程池有5个状态，分别是：  RUNNING：可以接受新的任务，也可以处理阻塞队列里的任务 SHUTDOWN：不接受新的任务，但是可以处理阻塞队列里的任务 STOP：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务 TIDYING：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200330233559797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-05-16T17:25:12.000Z">
<meta property="article:modified_time" content="2020-05-16T17:25:41.320Z">
<meta property="article:author" content="yuanxindong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200330233559797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/yuanxindong.github.io/atom.xml" title="Welcome to Jeff&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/yuanxindong.github.io/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/yuanxindong.github.io/" id="logo">Welcome to Jeff&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/yuanxindong.github.io/" id="subtitle">study&amp;Live</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/yuanxindong.github.io/">Home</a>
        
          <a class="main-nav-link" href="/yuanxindong.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/yuanxindong.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yuanxdxindong.github.io/yuanxindong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ThreadPoolExcutor源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-05-16T17:25:12.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ThreadPoolExcutor源码分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ThreadPoolExecutor的状态和属性"><a href="#ThreadPoolExecutor的状态和属性" class="headerlink" title="ThreadPoolExecutor的状态和属性"></a>ThreadPoolExecutor的状态和属性</h3><p>ThreadPoolExecutor线程池有5个状态，分别是：</p>
<ul>
<li>RUNNING：可以接受新的任务，也可以处理阻塞队列里的任务</li>
<li>SHUTDOWN：不接受新的任务，但是可以处理阻塞队列里的任务</li>
<li>STOP：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务</li>
<li>TIDYING：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个时候线程池的状态将会TIDYING，并且将要调用terminated方法</li>
<li>TERMINATED：终止状态。terminated方法调用完成以后的状态</li>
</ul>
<p>状态之间可以进行转换：</p>
<p>RUNNING -&gt; SHUTDOWN：手动调用shutdown方法，或者ThreadPoolExecutor要被GC回收的时候调用finalize方法，finalize方法内部也会调用shutdown方法</p>
<p>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow方法</p>
<p>SHUTDOWN -&gt; TIDYING：当队列和线程池都为空的时候</p>
<p>STOP -&gt; TIDYING：当线程池为空的时候</p>
<p>TIDYING -&gt; TERMINATED：terminated方法调用完成之后</p>
<p>ThreadPoolExecutor内部还保存着线程池的有效线程个数。</p>
<p>状态和线程数在ThreadPoolExecutor内部使用一个整型变量保存，没错，一个变量表示两种含义</p>
<p>为什么一个整型变量既可以保存状态，又可以保存数量？ 分析一下：</p>
<ol>
<li>首先，我们知道java中1个整型占4个字节，也就是32位，所以1个整型有32位。<br>所以整型1用二进制表示就是：00000000000000000000000000000001</li>
<li>整型-1用二进制表示就是：11111111111111111111111111111111(这个是补码，不懂的同学可以看下原码，反码，补码的知识)</li>
<li>在ThreadPoolExecutor，整型中32位的前3位用来表示线程池状态，后3位表示线程池中有效的线程数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 前3位表示状态，所有线程数占29位</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br></pre></td></tr></table></figure>
<p>线程池容量大小为 1 &lt;&lt; 29 - 1 = 00011111111111111111111111111111(二进制)，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br></pre></td></tr></table></figure>
<p>RUNNING状态 -1 &lt;&lt; 29 = 11111111111111111111111111111111 &lt;&lt; 29 =<br>11100000000000000000000000000000(前3位为111)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>


<p>SHUTDOWN状态 0 &lt;&lt; 29 = 00000000000000000000000000000000 &lt;&lt; 29 = 00000000000000000000000000000000(前3位为000)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>STOP状态 1 &lt;&lt; 29 = 00000000000000000000000000000001 &lt;&lt; 29 = 00100000000000000000000000000000(前3位为001)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>TIDYING状态 2 &lt;&lt; 29 = 00000000000000000000000000000010 &lt;&lt; 29 = 01000000000000000000000000000000(前3位为010)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>TERMINATED状态 3 &lt;&lt; 29 = 00000000000000000000000000000011 &lt;&lt; 29 = 01100000000000000000000000000000(前3位为011)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>清楚状态位之后，下面是获得状态和线程数的内部方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 得到线程数，也就是后29位的数字。 直接跟CAPACITY做一个与操作即可，CAPACITY就是的值就 1 &lt;&lt; 29 - 1 &#x3D; 00011111111111111111111111111111。 与操作的话前面3位肯定为0，相当于直接取后29位的值</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 得到状态，CAPACITY的非操作得到的二进制位11100000000000000000000000000000，然后做在一个与操作，相当于直接取前3位的的值</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或操作。相当于更新数量和状态两个操作</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<p>线程池初始化状态线程数变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化状态和数量，状态为RUNNING，线程数为0</span><br><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor执行任务"><a href="#ThreadPoolExecutor执行任务" class="headerlink" title="ThreadPoolExecutor执行任务"></a>ThreadPoolExecutor执行任务</h3><p>使用ThreadPoolExecutor执行任务的时候，可以使用execute或submit方法，submit方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显地看到，submit方法内部使用了execute方法，而且submit方法是有返回值的。在调用execute方法之前，使用FutureTask包装一个Runnable，这个FutureTask就是返回值。</p>
<p>由于submit方法内部调用execute方法，所以execute方法就是执行任务的方法，来看一下execute方法，execute方法内部分3个步骤进行处理。</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步。丢到阻塞队列之后，还需要再做一次验证(丢到阻塞队列之后可能另外一个线程关闭了线程池或者刚刚加入到队列的线程死了)。如果这个时候线程池不在RUNNING状态，把刚刚丢入队列的任务remove掉，调用reject方法，否则查看Worker数量，如果Worker数量为0，起一个新的Worker去阻塞队列里拿任务执行</li>
<li>丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法<br>上面说的Worker可以暂时理解为一个执行任务的线程。</li>
</ol>
<p>execute方法源码如下，上面提到的3个步骤对应源码中的3个注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;   &#x2F;&#x2F; 第一个步骤，满足线程池中的线程大小比基本大小要小</span><br><span class="line">        if (addWorker(command, true)) &#x2F;&#x2F; addWorker方法第二个参数true表示使用基本大小</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; &#x2F;&#x2F; 第二个步骤，线程池的线程大小比基本大小要大，并且线程池还在RUNNING状态，阻塞队列也没满的情况，加到阻塞队列里</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command)) &#x2F;&#x2F; 虽然满足了第二个步骤，但是这个时候可能突然线程池关闭了，所以再做一层判断</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!addWorker(command, false)) &#x2F;&#x2F; 第三个步骤，直接使用线程池最大大小。addWorker方法第二个参数false表示使用最大大小</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addWorker关系着如何起一个线程，再看addWorker方法之前，先看一下ThreadPoolExecutor的一个内部类Worker, Worker是一个AQS的实现类(为何设计成一个AQS在闲置Worker里会说明)，同时也是一个实现Runnable的类，使用独占锁，它的构造函数只接受一个Runnable参数，内部保存着这个Runnable属性，还有一个thread线程属性用于包装这个Runnable(这个thread属性使用ThreadFactory构造，在构造函数内完成thread线程的构造)，另外还有一个completedTasks计数器表示这个Worker完成的任务数。Worker类复写了run方法，使用ThreadPoolExecutor的runWorker方法(在addWorker方法里调用)，直接启动Worker的话，会调用ThreadPoolExecutor的runWork方法。==需要特别注意的是这个Worker是实现了Runnable接口的，thread线程属性使用ThreadFactory构造Thread的时候，构造的Thread中使用的Runnable其实就是Worker==。下面的Worker的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker    </span><br><span class="line">    extends AbstractQueuedSynchronizer</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This class will never be serialized, but we provide a</span><br><span class="line">     * serialVersionUID to suppress a javac warning.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6138294804551838833L;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;</span><br><span class="line">    final Thread thread;</span><br><span class="line">    &#x2F;** Initial task to run.  Possibly null. *&#x2F;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    &#x2F;** Per-thread task counter *&#x2F;</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="line">     * @param firstTask the first task (null if none)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用ThreadFactory构造Thread，这个构造的Thread内部的Runnable就是本身，也就是Worker。所以得到Worker的thread并start的时候，会执行Worker的run方法，也就是执行ThreadPoolExecutor的runWorker方法</span><br><span class="line">        setState(-1); 把状态位设置成-1，这样任何线程都不能得到Worker的锁，除非调用了unlock方法。这个unlock方法会在runWorker方法中一开始就调用，这是为了确保Worker构造出来之后，没有任何线程能够得到它的锁，除非调用了runWorker之后，其他线程才能获得Worker的锁</span><br><span class="line">        this.firstTask &#x3D; firstTask;</span><br><span class="line">        this.thread &#x3D; getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Delegates main run loop to outer runWorker  *&#x2F;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Lock methods</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; The value 0 represents the unlocked state.</span><br><span class="line">    &#x2F;&#x2F; The value 1 represents the locked state.</span><br><span class="line"></span><br><span class="line">    protected boolean isHeldExclusively() &#123;</span><br><span class="line">        return getState() !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">        if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryRelease(int unused) &#123;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        setState(0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">    public void unlock()      &#123; release(1); &#125;</span><br><span class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    void interruptIfStarted() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下addWorker源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 两个参数，firstTask表示需要跑的任务。boolean类型的core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span><br><span class="line">&#x2F;&#x2F; 返回值是boolean类型，true表示新任务被接收了，并且执行了。否则是false</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c); &#x2F;&#x2F; 线程池当前状态</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这个判断转换成 rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs !&#x3D; SHUTDOWN || firstTask !&#x3D; null || workQueue.isEmpty)。 </span><br><span class="line">        &#x2F;&#x2F; 概括为3个条件：</span><br><span class="line">        &#x2F;&#x2F; 1. 线程池不在RUNNING状态并且状态是STOP、TIDYING或TERMINATED中的任意一种状态</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 线程池不在RUNNING状态，线程池接受了新的任务 </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 线程池不在RUNNING状态，阻塞队列为空。  满足这3个条件中的任意一个的话，拒绝执行任务</span><br><span class="line"></span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c); &#x2F;&#x2F; 线程池线程个数</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize)) &#x2F;&#x2F; 如果线程池线程数量超过线程池最大容量或者线程数量超过了基本大小(core参数为true，core参数为false的话判断超过最大大小)</span><br><span class="line">                return false; &#x2F;&#x2F; 超过直接返回false</span><br><span class="line">            if (compareAndIncrementWorkerCount(c)) &#x2F;&#x2F; 没有超过各种大小的话，cas操作线程池线程数量+1，cas成功的话跳出循环</span><br><span class="line">                break retry;</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; 重新检查状态</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs) &#x2F;&#x2F; 如果状态改变了，重新循环操作</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 走到这一步说明cas操作成功了，线程池线程数量+1</span><br><span class="line">    boolean workerStarted &#x3D; false; &#x2F;&#x2F; 任务是否成功启动标识</span><br><span class="line">    boolean workerAdded &#x3D; false; &#x2F;&#x2F; 任务是否添加成功标识</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock; &#x2F;&#x2F; 得到线程池的可重入锁</span><br><span class="line">        w &#x3D; new Worker(firstTask); &#x2F;&#x2F; 基于任务firstTask构造worker</span><br><span class="line">        final Thread t &#x3D; w.thread; &#x2F;&#x2F; 使用Worker的属性thread，这个thread是使用ThreadFactory构造出来的</span><br><span class="line">        if (t !&#x3D; null) &#123; &#x2F;&#x2F; ThreadFactory构造出的Thread有可能是null，做个判断</span><br><span class="line">            mainLock.lock(); &#x2F;&#x2F; 锁住，防止并发</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 在锁住之后再重新检测一下状态</span><br><span class="line">                int c &#x3D; ctl.get();</span><br><span class="line">                int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123; &#x2F;&#x2F; 如果线程池在RUNNING状态或者线程池在SHUTDOWN状态并且任务是个null</span><br><span class="line">                    if (t.isAlive()) &#x2F;&#x2F; 判断线程是否还活着，也就是说线程已经启动并且还没死掉</span><br><span class="line">                        throw new IllegalThreadStateException(); &#x2F;&#x2F; 如果存在已经启动并且还没死的线程，抛出异常</span><br><span class="line">                    workers.add(w); &#x2F;&#x2F; worker添加到线程池的workers属性中，是个HashSet</span><br><span class="line">                    int s &#x3D; workers.size(); &#x2F;&#x2F; 得到目前线程池中的线程个数</span><br><span class="line">                    if (s &gt; largestPoolSize) &#x2F;&#x2F; 如果线程池中的线程个数超过了线程池中的最大线程数时，更新一下这个最大线程数</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    workerAdded &#x3D; true; &#x2F;&#x2F; 标识一下任务已经添加成功</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123; &#x2F;&#x2F; 如果任务添加成功，运行任务，改变一下任务成功启动标识</span><br><span class="line">                t.start(); &#x2F;&#x2F; 启动线程，这里的t是Worker中的thread属性，所以相当于就是调用了Worker的run方法</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted) &#x2F;&#x2F; 如果任务启动失败，调用addWorkerFailed方法</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Worker中的线程start的时候，调用Worker本身run方法，这个run方法之前分析过，调用外部类ThreadPoolExecutor的runWorker方法，直接看runWorker方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt &#x3D; Thread.currentThread(); &#x2F;&#x2F; 得到当前线程</span><br><span class="line">    Runnable task &#x3D; w.firstTask; &#x2F;&#x2F; 得到Worker中的任务task，也就是用户传入的task</span><br><span class="line">    w.firstTask &#x3D; null; &#x2F;&#x2F; 将Worker中的任务置空</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts。 </span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果worker中的任务不为空，继续知否，否则使用getTask获得任务。一直死循环，除非得到的任务为空才退出</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();  &#x2F;&#x2F; 如果拿到了任务，给自己上锁，表示当前Worker已经要开始执行任务了，已经不是闲置Worker(闲置Worker的解释请看下面的线程池关闭)</span><br><span class="line">            &#x2F;&#x2F; 在执行任务之前先做一些处理。 1. 如果线程池已经处于STOP状态并且当前线程没有被中断，中断线程 2. 如果线程池还处于RUNNING或SHUTDOWN状态，并且当前线程已经被中断了，重新检查一下线程池状态，如果处于STOP状态并且没有被中断，那么中断线程</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task); &#x2F;&#x2F; 任务执行前需要做什么，ThreadPoolExecutor是个空实现</span><br><span class="line">                Throwable thrown &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run(); &#x2F;&#x2F; 真正的开始执行任务，调用的是run方法，而不是start方法。这里run的时候可能会被中断，比如线程池调用了shutdownNow方法</span><br><span class="line">                &#125; catch (RuntimeException x) &#123; &#x2F;&#x2F; 任务执行发生的异常全部抛出，不在runWorker中处理</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown); &#x2F;&#x2F; 任务执行结束需要做什么，ThreadPoolExecutor是个空实现</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task &#x3D; null;</span><br><span class="line">                w.completedTasks++; &#x2F;&#x2F; 记录执行任务的个数</span><br><span class="line">                w.unlock(); &#x2F;&#x2F; 执行完任务之后，解锁，Worker变成闲置Worker</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly); &#x2F;&#x2F; 回收Worker方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下getTask方法是如何获得任务的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果发生了以下四件事中的任意一件，那么Worker需要被回收：</span><br><span class="line">&#x2F;&#x2F; 1. Worker个数比线程池最大大小要大</span><br><span class="line">&#x2F;&#x2F; 2. 线程池处于STOP状态</span><br><span class="line">&#x2F;&#x2F; 3. 线程池处于SHUTDOWN状态并且阻塞队列为空</span><br><span class="line">&#x2F;&#x2F; 4. 使用超时时间从阻塞队列里拿数据，并且超时之后没有拿到数据(allowCoreThreadTimeOut || workerCount &gt; corePoolSize)</span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut &#x3D; false; &#x2F;&#x2F; 如果使用超时时间并且也没有拿到任务的标识</span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果线程池是SHUTDOWN状态并且阻塞队列为空的话，worker数量减一，直接返回null(SHUTDOWN状态还会处理阻塞队列任务，但是阻塞队列为空的话就结束了)，如果线程池是STOP状态的话，worker数量建议，直接返回null(STOP状态不处理阻塞队列任务)[方法一开始注释的2，3两点，返回null，开始Worker回收]</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean timed;      &#x2F;&#x2F; 标记从队列中取任务时是否设置超时时间，如果为true说明这个worker可能需要回收，为false的话这个worker会一直存在，并且阻塞当前线程等待阻塞队列中有数据</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c); &#x2F;&#x2F; 得到当前线程池Worker个数</span><br><span class="line">            &#x2F;&#x2F; allowCoreThreadTimeOut属性默认为false，表示线程池中的核心线程在闲置状态下还保留在池中；如果是true表示核心线程使用keepAliveTime这个参数来作为超时时间</span><br><span class="line">            &#x2F;&#x2F; 如果worker数量比基本大小要大的话，timed就为true，需要进行回收worker</span><br><span class="line">            timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize; </span><br><span class="line"></span><br><span class="line">            if (wc &lt;&#x3D; maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)) &#x2F;&#x2F; 方法一开始注释的1，4两点，会进行下一步worker数量减一</span><br><span class="line">                break;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c)) &#x2F;&#x2F; worker数量减一，返回null，之后会进行Worker回收工作</span><br><span class="line">                return null;</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; 重新检查线程池状态</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs) &#x2F;&#x2F; 线程池状态改变的话重新开始外部循环，否则继续内部循环</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果需要设置超时时间，使用poll方法，否则使用take方法一直阻塞等待阻塞队列新进数据</span><br><span class="line">            Runnable r &#x3D; timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r !&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut &#x3D; true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut &#x3D; false; &#x2F;&#x2F; 闲置Worker被中断</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果getTask返回的是null，那说明阻塞队列已经没有任务并且当前调用getTask的Worker需要被回收，那么会调用processWorkerExit方法进行回收：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    if (completedAbruptly) &#x2F;&#x2F; 如果Worker没有正常结束流程调用processWorkerExit方法，worker数量减一。如果是正常结束的话，在getTask方法里worker数量已经减一了</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 加锁，防止并发问题</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount +&#x3D; w.completedTasks; &#x2F;&#x2F; 记录总的完成任务数</span><br><span class="line">        workers.remove(w); &#x2F;&#x2F; 线程池的worker集合删除掉需要回收的Worker</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate(); &#x2F;&#x2F; 尝试结束线程池</span><br><span class="line"></span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;  &#x2F;&#x2F; 如果线程池还处于RUNNING或者SHUTDOWN状态</span><br><span class="line">        if (!completedAbruptly) &#123; &#x2F;&#x2F; Worker是正常结束流程的话</span><br><span class="line">            int min &#x3D; allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min &#x3D;&#x3D; 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min &#x3D; 1;</span><br><span class="line">            if (workerCountOf(c) &gt;&#x3D; min)</span><br><span class="line">                return; &#x2F;&#x2F; 不需要新开一个Worker</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 新开一个Worker代替原先的Worker</span><br><span class="line">        &#x2F;&#x2F; 新开一个Worker需要满足以下3个条件中的任意一个：</span><br><span class="line">        &#x2F;&#x2F; 1. 用户执行的任务发生了异常</span><br><span class="line">        &#x2F;&#x2F; 2. Worker数量比线程池基本大小要小</span><br><span class="line">        &#x2F;&#x2F; 3. 阻塞队列不空但是没有任何Worker在工作</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在回收Worker的时候线程池会尝试结束自己的运行，tryTerminate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 满足3个条件中的任意一个，不终止线程池</span><br><span class="line">        &#x2F;&#x2F; 1. 线程池还在运行，不能终止</span><br><span class="line">        &#x2F;&#x2F; 2. 线程池处于TIDYING或TERMINATED状态，说明已经在关闭了，不允许继续处理</span><br><span class="line">        &#x2F;&#x2F; 3. 线程池处于SHUTDOWN状态并且阻塞队列不为空，这时候还需要处理阻塞队列的任务，不能终止线程池</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F; 走到这一步说明线程池已经不在运行，阻塞队列已经没有任务，但是还要回收正在工作的Worker</span><br><span class="line">        if (workerCountOf(c) !&#x3D; 0) &#123;</span><br><span class="line">             &#x2F;&#x2F; 由于线程池不运行了，调用了线程池的关闭方法，在解释线程池的关闭原理的时候会说道这个方法</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE); &#x2F;&#x2F; 中断闲置Worker，直到回收全部的Worker。这里没有那么暴力，只中断一个，中断之后退出方法，中断了Worker之后，Worker会回收，然后还是会调用tryTerminate方法，如果还有闲置线程，那么继续中断</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 走到这里说明worker已经全部回收了，并且线程池已经不在运行，阻塞队列已经没有任务。可以准备结束线程池了</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock(); &#x2F;&#x2F; 加锁，防止并发</span><br><span class="line">        try &#123;</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; &#x2F;&#x2F; cas操作，将线程池状态改成TIDYING</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated(); &#x2F;&#x2F; 调用terminated方法</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0)); &#x2F;&#x2F; terminated方法调用完毕之后，状态变为TERMINATED</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释了这么多，对线程池的启动并且执行任务做一个总结：</p>
<p>首先，构造线程池的时候，需要一些参数。一些重要的参数解释在 java内置的线程池笔记 文章中的结尾已经说明了一下重要参数的意义。</p>
<p>线程池构造完毕之后，如果用户调用了execute或者submit方法的时候，最后都会使用execute方法执行。</p>
<p>execute方法内部分3种情况处理任务：</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步</li>
<li>丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法</li>
</ol>
<p>线程池中的这个基本大小指的是Worker的数量。一个Worker是一个Runnable的实现类，会被当做一个线程进行启动。Worker内部带有一个Runnable属性firstTask，这个firstTask可以为null，为null的话Worker会去阻塞队列拿任务执行，否则会先执行这个任务，执行完毕之后再去阻塞队列继续拿任务执行。</p>
<p>所以说如果Worker数量超过了基本大小，那么任务都会在阻塞队列里，当Worker执行完了它的第一个任务之后，就会去阻塞队列里拿其他任务继续执行。</p>
<p>Worker在执行的时候会根据一些参数进行调节，比如Worker数量超过了线程池基本大小或者超时时间到了等因素，这个时候Worker会被线程池回收，线程池会尽量保持内部的Worker数量不超过基本大小。</p>
<p>另外Worker执行任务的时候调用的是Runnable的run方法，而不是start方法，调用了start方法就相当于另外再起一个线程了。</p>
<p>Worker在回收的时候会尝试终止线程池。尝试关闭线程池的时候，会检查是否还有Worker在工作，检查线程池的状态，没问题的话会将状态过度到TIDYING状态，之后调用terminated方法，terminated方法调用完成之后将线程池状态更新到TERMINATED。</p>
<h3 id="ThreadPoolExecutor的关闭"><a href="#ThreadPoolExecutor的关闭" class="headerlink" title="ThreadPoolExecutor的关闭"></a>ThreadPoolExecutor的关闭</h3><p>线程池的启动过程分析好了之后，接下来看线程池的关闭操作：</p>
<p>shutdown方法，关闭线程池，关闭之后阻塞队列里的任务不受影响，会继续被Worker处理，但是新的任务不会被接受：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 关闭的时候需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess(); &#x2F;&#x2F; 检查关闭线程池的权限</span><br><span class="line">        advanceRunState(SHUTDOWN); &#x2F;&#x2F; 把线程池状态更新到SHUTDOWN</span><br><span class="line">        interruptIdleWorkers(); &#x2F;&#x2F; 中断闲置的Worker</span><br><span class="line">        onShutdown(); &#x2F;&#x2F; 钩子方法，默认不处理。ScheduledThreadPoolExecutor会做一些处理</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); &#x2F;&#x2F; 尝试结束线程池，上面已经分析过了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interruptIdleWorkers方法，注意，这个方法打断的是闲置Worker，打断闲置Worker之后，getTask方法会返回null，然后Worker会被回收。那什么是闲置Worker呢？</p>
<p>闲置Worker是这样解释的：Worker运行的时候会去阻塞队列拿数据(getTask方法)，拿的时候如果没有设置超时时间，那么会一直阻塞等待阻塞队列进数据，这样的Worker就被称为闲置Worker。由于Worker也是一个AQS，在runWorker方法里会有一对lock和unlock操作，这对lock操作是为了确保Worker不是一个闲置Worker。</p>
<p>所以Worker被设计成一个AQS是为了根据Worker的锁来判断是否是闲置线程，是否可以被强制中断。</p>
<p>下面我们看下interruptIdleWorkers方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用他的一个重载方法，传入了参数false，表示要中断所有的正在运行的闲置Worker，如果为true表示只打断一个闲置Worker</span><br><span class="line">private void interruptIdleWorkers() &#123;</span><br><span class="line">    interruptIdleWorkers(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 中断闲置Worker需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers) &#123; </span><br><span class="line">            Thread t &#x3D; w.thread; &#x2F;&#x2F; 拿到worker中的线程</span><br><span class="line">            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; &#x2F;&#x2F; Worker中的线程没有被打断并且Worker可以获取锁，这里Worker能获取锁说明Worker是个闲置Worker，在阻塞队列里拿数据一直被阻塞，没有数据进来。如果没有获取到Worker锁，说明Worker还在执行任务，不进行中断(shutdown方法不会中断正在执行的任务)</span><br><span class="line">                try &#123;</span><br><span class="line">                    t.interrupt();  &#x2F;&#x2F; 中断Worker线程</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    w.unlock(); &#x2F;&#x2F; 释放Worker锁</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (onlyOne) &#x2F;&#x2F; 如果只打断1个Worker的话，直接break退出，否则，遍历所有的Worker</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdown方法将线程池状态改成SHUTDOWN，线程池还能继续处理阻塞队列里的任务，并且会回收一些闲置的Worker。但是shutdownNow方法不一样，它会把线程池状态改成STOP状态，这样不会处理阻塞队列里的任务，也不会处理新的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; shutdownNow方法会有返回值的，返回的是一个任务列表，而shutdown方法没有返回值</span><br><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; shutdownNow操作也需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess(); &#x2F;&#x2F; 检查关闭线程池的权限</span><br><span class="line">        advanceRunState(STOP); &#x2F;&#x2F; 把线程池状态更新到STOP</span><br><span class="line">        interruptWorkers(); &#x2F;&#x2F; 中断Worker的运行</span><br><span class="line">        tasks &#x3D; drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); &#x2F;&#x2F; 尝试结束线程池，上面已经分析过了</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br><span class="line">shutdownNow的中断和shutdown方法不一样，调用的是interruptWorkers方法：</span><br><span class="line"></span><br><span class="line">private void interruptWorkers() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 中断Worker需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted(); &#x2F;&#x2F; 中断Worker的执行</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Worker的interruptIfStarted方法中断Worker的执行：</span><br><span class="line"></span><br><span class="line">void interruptIfStarted() &#123;</span><br><span class="line">   Thread t;</span><br><span class="line">   &#x2F;&#x2F; Worker无论是否被持有锁，只要还没被中断，那就中断Worker</span><br><span class="line">   if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           t.interrupt(); &#x2F;&#x2F; 强行中断Worker的执行</span><br><span class="line">       &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池关闭总结：</p>
<p>线程池的关闭主要是两个方法，shutdown和shutdownNow方法。</p>
<p>shutdown方法会更新状态到SHUTDOWN，不会影响阻塞队列里任务的执行，但是不会执行新进来的任务。同时也会回收闲置的Worker，闲置Worker的定义上面已经说过了。</p>
<p>shutdownNow方法会更新状态到STOP，会影响阻塞队列的任务执行，也不会执行新进来的任务。同时会回收所有的Worker。</p>
<p>上一个图： <img src="https://img-blog.csdnimg.cn/20200330233559797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>原文链接：<a href="https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" target="_blank" rel="noopener">https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="cka9wnu4k0002d67vc518ef06" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/yuanxindong.github.io/2020/05/17/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          HTTP基础知识
        
      </div>
    </a>
  
  
    <a href="/yuanxindong.github.io/2020/05/17/mysql%E4%B8%ADchar%E5%92%8Cvarchar/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">mysql中char和varchar</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/yuanxindong.github.io/archives/2020/05/">五月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/">比特币和区块链技术</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">HTTP基础知识</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ThreadPoolExcutor源码分析</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/mysql%E4%B8%ADchar%E5%92%8Cvarchar/">mysql中char和varchar</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/JVM%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">JVM线上内存问题排查</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 yuanxindong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/yuanxindong.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/yuanxindong.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/yuanxindong.github.io/fancybox/jquery.fancybox.css">

  
<script src="/yuanxindong.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/yuanxindong.github.io/js/script.js"></script>




  </div>
</body>
</html>