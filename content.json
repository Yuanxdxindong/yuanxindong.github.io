{"meta":{"title":"Welcome to Jeff's blog","subtitle":"study&Live","description":"java","author":"yuanxindong","url":"http://www.yuanxindong.com","root":"/"},"pages":[],"posts":[{"title":"spring state machine","slug":"spring-state-machine","date":"2020-05-23T09:45:32.000Z","updated":"2020-05-23T09:45:53.450Z","comments":true,"path":"2020/05/23/spring-state-machine/","link":"","permalink":"http://www.yuanxindong.com/2020/05/23/spring-state-machine/","excerpt":"","text":"简单入门简单状态机（状态无层次结构，不存在子状态）Turnstile是一个简单的设备，如果付款完成，您可以访问该设备，并且使用状态机进行建模非常简单。 最简单的形式是只有两个状态，LOCKED和UNLOCKED。 如果您尝试通过它或您付款，可能会发生两个事件，COIN和PUSH。 状态 public enum States { LOCKED, UNLOCKED }事件 public enum Events { COIN, PUSH }状态机配置 @Configuration @EnableStateMachine static class StateMachineConfig extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; { @Override public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states) throws Exception { states .withStates() .initial(States.LOCKED) //配置初始状态 .states(EnumSet.allOf(States.class)); //导入所有状态 } @Override public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions) throws Exception { transitions //配置transition .withExternal() .source(States.LOCKED) //当接收到COIN事件 .target(States.UNLOCKED) //LOCKED--&gt; UNLOCKED .event(Events.COIN) .and() .withExternal() .source(States.UNLOCKED) //当接收到PUSH事件 .target(States.LOCKED) //UNLOCKED--&gt; LOCKED .event(Events.PUSH); } }多层次状态机Showcase是一个复杂的状态机，显示所有可能的转换拓扑结构，最多可达四级状态嵌套。 状态 public enum States { S0, S1, S11, S12, S2, S21, S211, S212 }事件 public enum Events { A, B, C, D, E, F, G, H, I }状态机配置状态关系 @Override public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states) throws Exception { states .withStates() .initial(States.S0, fooAction()) //初始化状态，初始化动作 .state(States.S0) //导入状态 .and() .withStates() //配置S0的子状态S1 .parent(States.S0) .initial(States.S1) .state(States.S1) .and() .withStates() //配置S1的子状态S11、S12 .parent(States.S1) .initial(States.S11) .state(States.S11) .state(States.S12) .and() .withStates() //配置S0的子状态S2 .parent(States.S0) .state(States.S2) .and() .withStates() //配置S2的子状态S21、S22 .parent(States.S2) .initial(States.S21) .state(States.S21) .and() .withStates() //配置S21的子状态S211、S212 .parent(States.S21) .initial(States.S211) .state(States.S211) .state(States.S212); }状态转移关系 @Override public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions) throws Exception { transitions .withExternal() .source(States.S1).target(States.S1).event(Events.A) //A：S1-&gt;S1 .guard(foo1Guard()) //配置guard .and() .withExternal() .source(States.S1).target(States.S11).event(Events.B) //B:S1-&gt;S11 .and() .withExternal() .source(States.S21).target(States.S211).event(Events.B) //B:S21-&gt;S211 .and() .withExternal() .source(States.S1).target(States.S2).event(Events.C) //C:S1-&gt;S2 .and() .withExternal() .source(States.S2).target(States.S1).event(Events.C) //C:S2-&gt;S1 .and() .withExternal() .source(States.S1).target(States.S0).event(Events.D) //D:S1-&gt;S0 .and() .withExternal() .source(States.S211).target(States.S21).event(Events.D) //D:S211-&gt;S21 .and() .withExternal() .source(States.S0).target(States.S211).event(Events.E) //E:S0-&gt;S211 .and() .withExternal() .source(States.S1).target(States.S211).event(Events.F) //F:S1-&gt;S211 .and() .withExternal() .source(States.S2).target(States.S11).event(Events.F) //F:S2-&gt;S11 .and() .withExternal() .source(States.S11).target(States.S211).event(Events.G) //G:S11-&gt;S211 .and() .withExternal() .source(States.S211).target(States.S0).event(Events.G) //G:S211-&gt;S0 .and() .withInternal() //内部转移，无状态变化 .source(States.S0).event(Events.H) .guard(foo0Guard()) .action(fooAction()) .and() .withInternal() //内部转移，无状态变化 .source(States.S2).event(Events.H) .guard(foo1Guard()) .action(fooAction()) .and() .withInternal() //内部转移，无状态变化 .source(States.S1).event(Events.H) .and() .withExternal() //I:S11-&gt;S12 .source(States.S11).target(States.S12).event(Events.I) .and() .withExternal() //I:S211-&gt;S212 .source(States.S211).target(States.S212).event(Events.I) .and() .withExternal() //I:S12-&gt;S212 .source(States.S12).target(States.S212).event(Events.I); }action&amp;guard @Bean public FooGuard foo0Guard() { return new FooGuard(0); } @Bean public FooGuard foo1Guard() { return new FooGuard(1); } @Bean public FooAction fooAction() { return new FooAction(); } private static class FooAction implements Action&lt;States, Events&gt; { @Override public void execute(StateContext&lt;States, Events&gt; context) { Map&lt;Object, Object&gt; variables = context.getExtendedState().getVariables(); Integer foo = context.getExtendedState().get(&quot;foo&quot;, Integer.class); if (foo == null) { log.info(&quot;Init foo to 0&quot;); variables.put(&quot;foo&quot;, 0); } else if (foo == 0) { log.info(&quot;Switch foo to 1&quot;); variables.put(&quot;foo&quot;, 1); } else if (foo == 1) { log.info(&quot;Switch foo to 0&quot;); variables.put(&quot;foo&quot;, 0); } } } private static class FooGuard implements Guard&lt;States, Events&gt; { private final int match; public FooGuard(int match) { this.match = match; } @Override public boolean evaluate(StateContext&lt;States, Events&gt; context) { Object foo = context.getExtendedState().getVariables().get(&quot;foo&quot;); return !(foo == null || !foo.equals(match)); } }","categories":[],"tags":[]},{"title":"mongoDB白皮书","slug":"mongoDB白皮书","date":"2020-05-21T05:14:01.000Z","updated":"2020-05-21T05:15:23.367Z","comments":true,"path":"2020/05/21/mongoDB白皮书/","link":"","permalink":"http://www.yuanxindong.com/2020/05/21/mongoDB%E7%99%BD%E7%9A%AE%E4%B9%A6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"520初始MongoDB","slug":"520初始MongoDB","date":"2020-05-20T18:08:42.000Z","updated":"2020-05-23T05:49:14.151Z","comments":true,"path":"2020/05/21/520初始MongoDB/","link":"","permalink":"http://www.yuanxindong.com/2020/05/21/520%E5%88%9D%E5%A7%8BMongoDB/","excerpt":"","text":"背景 由于我们在开发的过程中难免会遇到数据库选型的问题，那么数据库的选型那我们必须通过结合我们的业务场景还有他们的设计初衷，及各自在各个方面的优势。现在我们就在业务开发中遇到了选择 mongoDB还时MYsql。之前没有怎么了解过mongoDB，那今天就开始我的mongoDB第一步。 设计的初衷建立一种灵活，高效，易于扩展，功能完备的数据库。 1. 丰富的数据模型 mongo是面向文档的数据库，为了获得更好的扩展性采用的不是关系型数据库，使用一条记录就可以表示非常复杂的层次关系 没有固定的模式，文档的键值可以在应用层进行自己处理2. 容易扩展 由于大数据时代的来临，开发者遇到的问题就是如何扩展数据库。一般的关系性数据库做拓展最简单的方式也就是分库分表等，但是mongo采用的是文档模式可以自动在多台服务器间进行分割数据。还可以自动平衡负载和自动重排文档等3. 丰富的功能 索引 1.拥有铺筑索引，能进行多种快速查询，也提供唯一的，复合的和地理空间索引能力 存储JavaScript 聚合 MapReduce和其他聚合工具 固定集合 集合的大小是有上限的 文件存储 存储大型文件和文件元数据但是也有关系数据库中的功能不具备，那就是join查询，和多行事物。mongo的架构是为了提高性能和扩展性，但是这两个功能很难在一个分布式系统上实现。4. 不牺牲速度mongo的主要目标是卓越的性能，使用的传输协议是自己的传输协议作为服务器间交互的主要方式，他对文档进行动态填充，将内存管理工作交给操作系统去处理动态查询优化器会记住执行查询最高效的方式，也将类似于关系型数据库中的一部分业务交给了客户端去处理。5.简便的管理MonogDB尽量让服务器自治来简化数据库的管理。除了启动就再也没有什，么需要管理的地方了。如果有节点挂掉，mongo会自动去切换到从节点的机器上。 mongo的管理理念是尽可能的让服务器进行自动配置，让用户在需要时候调整设置。总结所有新事物的产生，都会有产生的原因，mongo也不列外，硬件水平提升，大数据时代的到来，关系型数据库出现暴露出了自己的性能瓶颈，如：全文检索导致数据响应时间慢，数据模型的固定导致业务修改成本高等等。mongo通过牺牲关系型数据库中部分功能（事物，join关联）来提高数据库的灵活性和高效性。及支持自动分区，提高数据库的扩展性 想一下和mysql关系型数据库的区别？ mysql的优势是什么呢？","categories":[],"tags":[]},{"title":"复盘","slug":"复盘","date":"2020-05-18T16:03:01.000Z","updated":"2020-05-18T16:07:52.596Z","comments":true,"path":"2020/05/19/复盘/","link":"","permalink":"http://www.yuanxindong.com/2020/05/19/%E5%A4%8D%E7%9B%98/","excerpt":"","text":"你所毕业的学校真的对于你来很重要。 第一件事： 那天中午，有一个今年就要毕业的实习生，很兴奋的跑过来跟我说：“X哥，我现在接受X业务模块了，听G哥说，你熟悉这块逻辑，以后还得多问问你。”。不得不说我挺替这位实习生高兴的。我说好啊，有问题你过来问我就行。然后过了有半个星期。我和那个实习生的师傅吃饭，我说怎么不见实习生了。他说：“被HR劝退了！”。我当时挺疑问的：“这娃挺上进的，怎么就不要了呢？”。他师傅说：“学校不行，今年就业形式不行，公司现在招985，211的哪些！”。 每一件事情对于你来说都很重要 第二件事： 公司组织业务考试，考试系统有bug，大家都是搞研发的，一不说二不休的直接把答案都搞出来了。最后大部分都考了高分。因为有满分且做的很快，于是高层领导怀疑有人作弊。组织让高分进行了重考，极少数人重视了第二次考试考过了，大部分人没有重视随意一答就出了考场。于是公司在没考过的人里面追查了下来。大部分人降职降薪。 到最后谁也没想到会有这么严重的结果。 这两件事情虽然我都幸免于难。但对我的感触颇为深厚。就当是今天通过这两件事情复盘一下自己。 从去年大学毕业都很顺利，一直到现在都还好，没有遇到什么大的困难和坎坷。也学到了很多东西，也养成了一些好的习惯。 但是针对于上面的两件事情，我都不够好，第一件我不是什么名校，但这只能怪以前的自己不够优秀，不够好。不能责怪现在的自己，一切问题都会有办法来解决。 那就是现在的自己弥补以前自己的缺失。不晚，一点也不晚。只要能静下心来，能够用心，这都是可以弥补过来的。就比如定个目标，让自己去一个可以“镀金”的公司。不断的去学习，提高自己的认知，提高自己的知识储备。到目前来看我有做到第一步不断提高自己的知识储备。但是还是不能够静下心来（效率不够高），目标还不是很明确，还有就是不够自信。再次在这里劝诫自己多出去“实战，实战”。 第二件事情对于我来说，完全是幸运，因为我当时也有“抄袭”，大概是没有抄好，到最后没有考到很高分。甚至我在考完得到分数感觉有一些懊悔（这他妈才考了这么点）。我完全没有重视这场考试，没有预习也没有复习。甚至“抄袭也没有抄好”。这就是问题。仔细想想以前的很多的小的问题我都没有做好，甚至到今天突然想到leader安排的一个指标监控还没有做好（有些时间了）。这就是问题吧。不得不承认我是一个邋遢的人。甚至可以说在平日里计划都不很明确的人。不是一个细心的人。大概是这样。没有计划，就会遗漏。再想想我真的做的很差在这方面。 这就是我的短板之一，写到这里还算是明确了。是的有短板就需要刻意练习。再扯回“对每件事都要重视”这件事情上，就说事我重视了这件事情，还有就是踏踏实实的自己干，那我完全不用浪费我的运气了。我会顺顺当当的过关。这又映射出另一件事情：“那就是踏踏实实做自己”。大概就是这样。写到这里也算明确了和正确理解了这两件事情。 总结一下： 继续加油持续充电，明确目标不断前进。 计划明确细心静心，脚踏实地弥补短板。 共勉！！！我感觉我适合做一个Rapper","categories":[],"tags":[]},{"title":"spring aop的实现原理","slug":"spring-aop的实现原理","date":"2020-05-18T01:16:43.000Z","updated":"2020-05-18T01:16:43.275Z","comments":true,"path":"2020/05/18/spring-aop的实现原理/","link":"","permalink":"http://www.yuanxindong.com/2020/05/18/spring-aop%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"以正确姿势理解区块链技术？","slug":"以正确姿势理解区块链技术？","date":"2020-05-17T05:20:13.000Z","updated":"2020-05-23T08:58:52.001Z","comments":true,"path":"2020/05/17/以正确姿势理解区块链技术？/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/%E4%BB%A5%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E7%90%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/","excerpt":"","text":"背景今天在看了一个视频《全球区块链全球生态技术大会》中的腾讯云通过区块链技术实现了一个针对于企业服务的Tbaas区块链基础服务平台。（视频地址:https://time.geekbang.org/dailylesson/detail/100016514），之前因比特币看过区块链这方面的技术，大概了解了一下区块链技术的中心思想。今天看一下我们目前区块链技术的落地方案。 什么是区块链技术？权威指南wiki百科：区块链（英语：blockchain[1][2][3]或block chain[4][5]）是借由密码学[1][6]串接并保护内容的串连文字记录（又称区块）。每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易数据（通常用默克尔树(Merkle tree)算法计算的散列值表示）[7]，这样的设计使得区块内容具有难以篡改的特性。用区块链技术所串接的分布式账本能让两方有效纪录交易，且可永久查验此交易。 个人理解区块链技术的目的是实现去中心化（弱中心化），为什么去中心化。因为去了中心化就不用某一个中心化用户来维护这份“账本数据”，可以动员所有的用户去维护这个账本（或联盟成员），这样可以让账本数据更加的透明化（可信任）。这些用户可以通过POW算法（分布式一致性算法）去维护这个帐本。这个账本之间都是依次相互联系的，通过加密算法进行账本间的相互依赖也就是可溯源。 我们再想想，比特币的初衷是去中心化，不再再去受某个机构或某个团体的监管，而区块链技术就是从其中分离出来的技术实现。所以区块链技术也就是去中心化（弱中心化）在去中心（弱中心化）的同时且能保证数据和系统的安全且遵循分布式系统的CAP理论。 区块链7个特征 区块链的存储基于分布式数据库； 数据库是区块链的数据载体，区块链是交易的业务逻辑载体； 区块链按时间序列化区块数据，整个网络有一个最终确定状态； 区块链只对添加有效，对其他操作无效； 交易基于非对称加密的公私钥验证； 区块链网络要求拜占庭将军容错; 共识算法能够“解决”双花问题。区块链的类型1. 共有链：我们先来介绍公有链。公有链 ，顾名思义，它是公有的、开放的。在区块链中，公有链是开放程度最高，也是去中心化属性最强的。 在公有链中，数据的数据的存储、更新、维护、操作都不再依赖于一个中心化的服务器，而是依赖于每一个网络节点，这就意味着，公有链上的数据是由全球互联网上成千上万的网络节点共同记录维护的，没有人能够擅自篡改其中的数据。 2. 联盟链：联盟链，是公司与公司、组织与组织之间达成联盟的模式，维护链上数据的节点都来自于该联盟中的公司或者组织，记录维护数据的权力掌握在联盟成员手中。采用联盟链的群体主要是：银行、保险、证券、商业协会、集团企业等。 联盟链其实很好理解，就是公司之间形成一种联盟的关系： 假设 A 公司、B 公司和 C 公司组成联盟链，那么，这条联盟链上的数据只对 A、B、C 三家公司的运维人员开放，维护联盟链的人只能是 A、B、C 三家公司的运维人员，只有他们才有操作数据的权利 3. 私有链私有链是一种不对外公开的、只有被授权的节点才可以参与并查看数据的私有区块链。采用私有链的群体主要是大型金融机构、大型企业、政府部门等。 私有链最典型的就是央行开发的、用于发行央行数字货币的区块链，这个链只能由央行来做记账，个人是不可能参与记账的。 区块链的核心技术组成1. P2P 网络协议P2P 网络协议是所有区块链的最底层模块，负责交易数据的网络传输和广播、节点发现和维护。 2. 分布式一致性算法（共识机制）在经典分布式计算领域，我们有 Raft 和 Paxos 算法家族代表的非拜占庭容错算法，以及具有拜占庭容错特性的 PBFT 共识算法。 PoW：通常是指在给定的约束下，求解一个特定难度的数学问题，谁解的速度快，谁就能获得记账权（出块）权利。这个求解过程往往会转换成计算问题，所以在比拼速度的情况下，也就变成了谁的计算方法更优，以及谁的设备性能更好。比特币本身的演化很好地诠释了这个问题，中本聪设计的思路本来是由 CPU 计算。随着市场发展，人们发现 GPU 也可以参与其中，而且效率可以达到十倍百倍，现在，这项工作基本以 ASIC 专业挖矿芯片为主。正如我们在挖矿的时候，买一台蚂蚁矿机53T，72T什么的，就是算力越高，收入就越高（也不一定）。 PoS：这是一种股权证明机制，它的基本概念是产生区块的难度应该与你在网络里所占的股权（所有权占比）成比例，目前有三个版本 PoS1.0、PoS2.0、PoS3.0。它实现的核心思路是：使用你所锁定代币的币龄（CoinAge）以及一个小的工作量证明，去计算一个目标值，当满足目标值时，你将可能获取记账权。 PoS：这是一种股权证明机制，它的基本概念是产生区块的难度应该与你在网络里所占的股权（所有权占比）成比例，目前有三个版本 PoS1.0、PoS2.0、PoS3.0。它实现的核心思路是：使用你所锁定代币的币龄（CoinAge）以及一个小的工作量证明，去计算一个目标值，当满足目标值时，你将可能获取记账权。3. 加密签名算法我们常见的算法，也就是hash算法中的SHA256，比特币采用的算法，在挖矿的时候也就是采用的是这个算法。总结大概认识完区块链后，区块链技术就是一个以去中心化（弱中心化）为目的，由多个用户来进行维护，对数据进行分布式存储记录。这些数据并且是不可篡改的。思考根据区块链的技术我们思考一下哪里能用到呢，如何落地一个区块链项目呢（除过类似于比特币）？ 就像腾讯云提供的TBAAS区块链的基础服务，那我们如何使用TBAAS 来应用到业务逻辑上呢？？ 参考：1. https://time.geekbang.org/column/article/5601《深入浅出区块链陈浩元界CTO》2. https://www.chainnews.com/articles/007931884124.htm《联闻》3. wiki百科：https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BEhe","categories":[],"tags":[]},{"title":"比特币白皮书","slug":"比特币白皮书","date":"2020-05-16T17:58:07.000Z","updated":"2020-05-16T18:03:39.093Z","comments":true,"path":"2020/05/17/比特币白皮书/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"比特币和区块链技术","slug":"比特币和区块链技术","date":"2020-05-16T17:28:38.000Z","updated":"2020-05-16T17:29:03.641Z","comments":true,"path":"2020/05/17/比特币和区块链技术/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/","excerpt":"","text":"起源： 比特币的创建者中本聪不满当时西方的货币政策。在他看来 , 西方国家中央银行对商业银行的保护以及其货币的过度增发是导致当时的金融危机的主要原因。exaple： 开始人们用物品换物品，但是由于在交换的过程中，出现了携带不方便，难以换算等问题? 为解决这个问题人们还是想到了说是使用金子，容易保存且比较稀有，相对于以前方便携带，于是人们开始了实物货币时代。但是又遇到问题了，金子资源不够了，也会有磨损。 又有人提出了使用纸币，将所有金子都上缴等价换纸币，纸币只能由固定的地方（政府银行）印出来才有效，拥有固定的标号和签字等。当有损坏的时候可以拿着纸币去银行换取新的那么旧的纸币就销毁掉。 虽然在使用纸币的时候没有怎么遇到非常致命的问题，但是造币太累了，还有就是有人制造假币等等问题 于是又有人提出，我们为什么不去搞一个账本，所有的交易记录都放在账本上，把每个人目前所拥有的纸币都交上来，然后在数据库里面维护账户的信息。但是这个玩意还是有问题，就是如果这个数据库管理员有私心把这个账簿改掉了，那怎么办。 于是有一个天才科学家“中本聪”来了，他说：我们不要具体记录某个人算好的账，如剩余多少钱，而是去记录所有的交易，那么每个人有多少钱就可以通过交易记录推算出来。并且这个交易记录账本交给大家来维护。于是来了这个去中心化的记账系统，也叫做A Peer-to-Peer Electronic Cash System（一个点对点电子现金系统）。 什么是blockchain，什么是Bitcoins？两着又有什么关系呢？ 类比一下吧，支付宝中的金额数就是BTC，其保证金额正常转账正常交易的系统就是区块链，我现在就是类比一下，但是支付宝和这玩意完全是两会事！！！！再强调一下，我的意思是blochain是技术，bitCoins是一个服务。使用blockchain实现了bitCoins！！！ 但是我个人觉得这玩意更像是一个有一定算法的数据结构。咋先入门不BB那么深了！！ 技术是用来干什么的，就是用来解决问题的吗！（也可以这么说吧，技术就是因为问题而产生的）那bitcoins都遇到了那些问题？而发明除了区块链这门技术？ 为什么要发明bitcoins系统呢？正如我上面的example，诚信吗，被一个人控制。这玩意容易被修改掉, 如果说让所有的人都去维护账簿那岂不是妙哉！还有就是 bitcoins 系统是一个 transaction-based ledger 也就是说它是基于账单记录的一个交易账簿。 所以说所有人都必须知道这个账簿的所有交易记录才能去做帐，才能计算出来自己的btc余额，那么这就来问题了！那既然账簿都公布出去了，那这玩意岂不是完犊子了，张三说我出去“玩”的花费岂不是被老婆知道了！！这不就GG了，聪哥说这简单啊！说他也想到了！他也有老婆啊！这就牵扯到了密码学中的Asymmetric encryption（非对称加密）和 hash 算法 。使用BTC系统的人在创建账户的时候会有两个key ，public key（公匙） 和 private key（私匙）public key也就是类似与我们的账号，private key 也就是类似于我们的密码。 这样的话那这谁也不知道这个是谁啊 ，还有人就会问那他老婆钥匙知道他的public key 那也不就知道他是谁了！！！！ hash的算法可不是吃素的，这个public key 和 private key 是通过hash 算法计算出来的 其中bitcoins 系统中使用的算法就是sha256 ， 比如你是jingyangchun 通过hash算法后直接变成256个由0和1组合打二进制代码。但是有人就说他老婆反算回来不就行了！！ 好吧 这个算法是反算不回来的。现在被老婆发现这个问题解决了，那会不会有创建的private key 和 public key 和其他人是一样的呢？ 这个算法的好处就是 colloction free 意思就是没有人能制造出hash 碰撞，hash碰撞的意思是 就是jingyangchun 在通过hash 计算后在人为的情况下是制造不出来相同的hash值的。所以说你是唯一的（这个的前提条件是：你的输入空间是足够大的，意思就是你这个jingyangchun简简单单的字符串是不行的，得再加 个字符串才可以的jingyangchun+weqhsvsdkhvsdkhdvhksvhk ）所以说账户的安全问题得到保证了！看下图！","categories":[],"tags":[]},{"title":"HTTP基础知识","slug":"HTTP基础知识","date":"2020-05-16T17:27:03.000Z","updated":"2020-05-16T17:27:19.001Z","comments":true,"path":"2020/05/17/HTTP基础知识/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"HTTP概述web浏览器，服务器和相关的web的应用程序都是通过HTTP进行通信交互的，http是现代全球因特网中使用的公共语言。http 使用的是 可靠地数据传输协议，因此即时数据来自地球的另一端，他也能够确保数据在传输的过程中不会被损坏。 1. HTTP中的名词1. Web客户端和服务器我们平常使用的就是浏览器就是web客户端，问客户端的信息来源那就是服务器，平时所说的应用程序就是在服务器上部署，好比微博，微博上的照片等资源就是从服务器来的。 2. 媒体类型客户端通过http请求服务端，会请求不同的资源，如视频，音频等等文件，所以http都为需要在web传书的资源都打上了类型，使用MIME的数据格式标签，打标记。这个标记一般都会存储在我们的首部（后面会讲到） 3. 资源web服务器是web资源的宿主，http是Web服务器和web客户端中间的媒介，资源的类型有很多种，包括我们所部属的应用程序列如jar包，或者是。class文件等等 3. URI每一个web服务器都有一个名字，这样客户端就知道他要的资源是什么，即URL uniform Resource Identifier 统一资源标识符。列如 https://blog.csdn.net/weixin_40413961/article/details/105398407 这个地址就是我博客的URI ，URI是怎样只是HTTP协议去访问我的博客资源的，给定了URI，就可以HTTP就可以解析出对象。URI 有两种形式分别为URL 和 URN 4. URL URL是统一资源的定位符，是资源标识符最常见的形式，URL描述了一台特定的服务器上的特定资源。他可以明确地从固定的位获取资源。 URL的组成： url的第一部分是HTTP 说明访问资源所使用的协议 blog.csdn.net给出服务器的因特网地址 其余的部分就制定了web服务器上的资源路径现在几乎所有的URI搜使用的是URL 5. URN 1.URN是代表的是某个资源，也就他叫做统一资源名 就举个例子：苹果在哪里都是苹果，只要你用苹果这个统一资源名就会获取到苹果（假如世界上的苹果都一样的前提下）无论你的苹果放在哪里，且可以通过任何的途径拿到。 6. 事务 http 的事务有一条请求命令（游客户端发往服务器）和响应结果组成（服务器发往客户端的）。这种通信是通过名为HTTP报文的的格式化数据块进行的 7. 方法 HTTP支持几种不同的HTTP请求命令，这些命令被称为HTTP方法，每一条HTTP报文都包含一个HTTP方法。这些方法会告诉HTTP服务器需要执行什么动作（但是服务器内的应用程序到底是如何执行的我们并不知道，列如我们请求的是get 但是，我们在代码里面处理的时候是删除） ， 7种HTTP方法： GET: GET通常用于请求服务器资源，HTTP/1.1是要求服务器实现此方法 GET和HEAD是HTTP方法中的安全方法，因为他两被赋予的意义是获取资源而不是去更改资源，所以说的安全的。注意：但是这里的安全仅仅是所有的开发遵循规则的情况下。就如我肯上面所提到的请求的是GET但是服务器的应用程序执行了删除操作。那这肯定就不安全了。 HEAD: HEAD 的请求方式和GET 的行为很类似，但是服务器在响应中只返回首部。不会返回实体的主体部分。他和GET的区别就是一个会返回实体一个不会返回实体 POST：POST语法的定义是向服务器输入数据的，实际上，通常会用他来支持HTML的表单，表单一半填好数据会发送给服务器，服务器会将他发送到他要去的地方，可以是网关等地方，然后由应用程序去处理 DELETE： 顾名思义那就是URL请求的资源进行删除，客户端的应用程序无法保证程序一定执行，因为HTTP规范语序服务在不通知客户端的情况下撤销删除。 OPTIONS： 此方法在我们的平时编程种感觉是很少使用的，此方法的语法意思是请求WEB服务器告知其支持的各种功能。可以询问服务器都支持哪些方法。 PUT： put语法的定义就是根据HTTP报文中的主体部分来创建一个由所请求的UR命名的新文档，或者这个URL已经存在就用这个主题来替代它。因为PUT会修改资源，所以很多WEB服务器都要求执行PUT之前，用密码登录。 TRACE： 当客户端发起一个请求的时候，这个请求有可能穿越防火墙，网关 ，代理等一些应用服务（列如一些回调服务）等，每一个中间节点都会对 hTTP报文进行修改。TRACE方法允许客户端在最终请求发送给服务器时，看看它变成了什么样子。TRACE请求会在目的服务器短发一个环回的诊断，行程最后的一站的服务器会返回一条 TRACE响应，并在响应的主体中返回接收到的请求报文。 8. 状态码 状态码 含义 100 -199 信息状态码 200-299 成功状态码 300-399 重定向资源码 400-499 客户端错误状态码 500-599 服务端错误状态吗 ### 9. 报文 1. 报文可以分为： 请求报文和响应报文 1. 报文的组成是：起始行， 首部，主体。 2. 请求报文和响应报文的区别是？ 3. 起始行可以分为两种：请求行和响应行两者的区别和组成如上图，不做赘述、请求行的其他组成： - 方法 - 状态码 - 原因短语 - HTTP版本号 4. 首部： - 通用首部 - 请求首部 - 响应首部 - 实体首部 说明实体的内部 - 扩展首部 ### 10. 连接 1. HTTP权威指南：“世界上几乎所有的HTTP通信都是通过TCP/IP承载的，TCP/IP是全球计算机及网络设备都是在使用的一种常用的分组交换网络协议集”那就是HTTP的连接是由TCP来进行的。 2. TCP提供可靠的数据管道，http连接实际上就是TCP连接及使用规则，TCP为HTTP提供可靠地比特传输管道，从TCP连接一段填入数据会从另一端有序的，正确得传送出来。 3. TCP流是分段的，是由IP分组传送的 。HTTP 要传输一条报文的时候，会以流的形式通过一条打开的TCP管道有序传输。TCP收到数据流，将流砍成被称作段的小数据块，并将段封装在IP分组里，通过因特网进行传输。这些操作都是通过TCP/IP软件来处理的。每一个TCP分段都是有IP分组来承担，从一个ip地址发送到另一个IP地址。我们可以类比一下快递公司，两个城市的派发中心就是TCP 其中运输的车就是IP 快递（一批快递）就是HTTP报文 两个城市的派发中心建立连接后，将其快递封装在一辆辆的车里然后通过两个快递派发中心制定的路线管道有序正确的运输到目的地 4. TCP保持连接持续不断的运行，在计算机中在任意时刻都会有几条TCP连接处于打开状态。TCP是通过端口号 来保持所有的这些连接不断地运行 5. 使用TCP的套接字去编程，我们在写Java的时候操作协同会给我们提供操作TCP的API。这就是SOCKET套接字API这个API 移隐藏了TCP 和IP的所有细节。具体过程 ### 11. TCP 性能考虑 1. HTTP紧挨着TCP，位于其上层，所以HTTP事务的性能在很大程度取决于底层TCP的性能 HTTP事务请求的过程中出现网络延时 1）客户端解析URI，找到对应的IP地址和端口号。如果本地缓存有就会节约很多的时间，如果本地没有就会就进去DNS获取这个时间回达到数10秒 2）客户端会发起TCP连接请求，并等待服务器返回一个接收链接的应答。这个请求回达到1到2S 3） 一旦连接建立起来吗，客户端就会通过新建立的TCP管道来发送HTTP请求数据到达后就会对其中的请求报文进行处理。在进行处理也是会耗时的，主要是是取决于HTTP服务器的应用程序的性能。 4）web服务器响应 回送HTTP响应。也是耗时的 TCP网络延时的大小取决于硬件速度，网络和服务器的负载，请求和响应报文的尺寸，以及客户端介服务短的距离。2. TCP的性能聚焦 TCP连接建立握手： 在TCP建立连接的时候 会进行一些数据的确认和沟通，而达到确认建立连接（三次握手）。如果这次连接传入少量的得数据的话，这个建立连接的过程会严重降低HTTP的性能。TCP三次握手和四次挥手：https://blog.csdn.net/weixin_40413961/article/details/105397536 延时确认： 由于因特网自己无法保证数据的可靠传输所以TCP担任其这一重任，在每次传输完IP分组到目标地址的时候都会向发送端返回一个确认报文，由于报文很小，所以TCP允许在发往允许在发往相同方向的输出数据进行捎带。所以就有了延迟算法。将这个确认报文存放在本地的缓存里面，如果有回去的数据就将缓存里里面的报文稍待返回，100——200MS内没有的话，就单独返回确认报文 TCP慢启动拥塞控制 ：TCP 数据的传输的性能还取决于TCp连接的使用期.tcp连接会随着时间进行自我调谐，起处会限制连接的最大速度，如果数据传输成功了，会随着时间得推移，提高传输速度 。这种调节被称为TCP的慢启动用于因特网的突然过载和拥塞 数据聚集Nagle算法 ： TCP 有一个数据流入口应用程序可以将任意的尺寸的大小的数据放入TCP栈中，既是一次放入一个字节也是可以的。但是每每一个每个TCP段中都至少装载了40个字节的标记和首部。所以TCP发送大量包含少量数据的分组，网络的性能就会严重下降。nagle算法就是在发送一个分组之前，将大量的TCP 数据绑定在一起以提高网络的效率。NElage算法会因为小的HTTP报文无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。因为需要将小的数据聚合起来一块的发送所以就是阻止HTTP报文的发送。这也就会影像http的传输 TIME—_WAIT时延和端口耗尽: 在TCP端点关闭TCP链接的时候，会在内存中维护一个小的控制块，用来记录最近关闭的IP地址和端口号，这类信息只会维护一短时间（2MSL 为两分钟），以确保在这段时间内不会重复的去创建相同的地址和端口号。由于现在高速路由一般会把2MSL调到特别小，就会 出现一些性能问题具体的说法可看点击-&gt;。（https://blog.csdn.net/u010585120/article/details/80826999）参考 ：HTTP权威指南","categories":[],"tags":[]},{"title":"ThreadPoolExcutor源码分析","slug":"ThreadPoolExcutor源码分析","date":"2020-05-16T17:25:12.000Z","updated":"2020-05-16T17:25:41.320Z","comments":true,"path":"2020/05/17/ThreadPoolExcutor源码分析/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"ThreadPoolExecutor的状态和属性ThreadPoolExecutor线程池有5个状态，分别是： RUNNING：可以接受新的任务，也可以处理阻塞队列里的任务 SHUTDOWN：不接受新的任务，但是可以处理阻塞队列里的任务 STOP：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务 TIDYING：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个时候线程池的状态将会TIDYING，并且将要调用terminated方法 TERMINATED：终止状态。terminated方法调用完成以后的状态 状态之间可以进行转换： RUNNING -&gt; SHUTDOWN：手动调用shutdown方法，或者ThreadPoolExecutor要被GC回收的时候调用finalize方法，finalize方法内部也会调用shutdown方法 (RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow方法 SHUTDOWN -&gt; TIDYING：当队列和线程池都为空的时候 STOP -&gt; TIDYING：当线程池为空的时候 TIDYING -&gt; TERMINATED：terminated方法调用完成之后 ThreadPoolExecutor内部还保存着线程池的有效线程个数。 状态和线程数在ThreadPoolExecutor内部使用一个整型变量保存，没错，一个变量表示两种含义 为什么一个整型变量既可以保存状态，又可以保存数量？ 分析一下： 首先，我们知道java中1个整型占4个字节，也就是32位，所以1个整型有32位。所以整型1用二进制表示就是：00000000000000000000000000000001 整型-1用二进制表示就是：11111111111111111111111111111111(这个是补码，不懂的同学可以看下原码，反码，补码的知识) 在ThreadPoolExecutor，整型中32位的前3位用来表示线程池状态，后3位表示线程池中有效的线程数。 12&#x2F;&#x2F; 前3位表示状态，所有线程数占29位private static final int COUNT_BITS &#x3D; Integer.SIZE - 3; 线程池容量大小为 1 &lt;&lt; 29 - 1 = 00011111111111111111111111111111(二进制)，代码如下 1private static final int CAPACITY &#x3D; (1 &lt;&lt; COUNT_BITS) - 1; RUNNING状态 -1 &lt;&lt; 29 = 11111111111111111111111111111111 &lt;&lt; 29 =11100000000000000000000000000000(前3位为111)： 1private static final int RUNNING &#x3D; -1 &lt;&lt; COUNT_BITS; SHUTDOWN状态 0 &lt;&lt; 29 = 00000000000000000000000000000000 &lt;&lt; 29 = 00000000000000000000000000000000(前3位为000) 1private static final int SHUTDOWN &#x3D; 0 &lt;&lt; COUNT_BITS; STOP状态 1 &lt;&lt; 29 = 00000000000000000000000000000001 &lt;&lt; 29 = 00100000000000000000000000000000(前3位为001)： 1private static final int STOP &#x3D; 1 &lt;&lt; COUNT_BITS; TIDYING状态 2 &lt;&lt; 29 = 00000000000000000000000000000010 &lt;&lt; 29 = 01000000000000000000000000000000(前3位为010)： 1private static final int TIDYING &#x3D; 2 &lt;&lt; COUNT_BITS; TERMINATED状态 3 &lt;&lt; 29 = 00000000000000000000000000000011 &lt;&lt; 29 = 01100000000000000000000000000000(前3位为011)： 1private static final int TERMINATED &#x3D; 3 &lt;&lt; COUNT_BITS; 清楚状态位之后，下面是获得状态和线程数的内部方法： 12345678&#x2F;&#x2F; 得到线程数，也就是后29位的数字。 直接跟CAPACITY做一个与操作即可，CAPACITY就是的值就 1 &lt;&lt; 29 - 1 &#x3D; 00011111111111111111111111111111。 与操作的话前面3位肯定为0，相当于直接取后29位的值private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;&#x2F;&#x2F; 得到状态，CAPACITY的非操作得到的二进制位11100000000000000000000000000000，然后做在一个与操作，相当于直接取前3位的的值private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;&#x2F;&#x2F; 或操作。相当于更新数量和状态两个操作private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 线程池初始化状态线程数变量： 12&#x2F;&#x2F; 初始化状态和数量，状态为RUNNING，线程数为0private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0)); ThreadPoolExecutor执行任务使用ThreadPoolExecutor执行任务的时候，可以使用execute或submit方法，submit方法如下： 123456public Future&lt;?&gt; submit(Runnable task) &#123; if (task &#x3D;&#x3D; null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null); execute(ftask); return ftask;&#125; 很明显地看到，submit方法内部使用了execute方法，而且submit方法是有返回值的。在调用execute方法之前，使用FutureTask包装一个Runnable，这个FutureTask就是返回值。 由于submit方法内部调用execute方法，所以execute方法就是执行任务的方法，来看一下execute方法，execute方法内部分3个步骤进行处理。 如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法 如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步。丢到阻塞队列之后，还需要再做一次验证(丢到阻塞队列之后可能另外一个线程关闭了线程池或者刚刚加入到队列的线程死了)。如果这个时候线程池不在RUNNING状态，把刚刚丢入队列的任务remove掉，调用reject方法，否则查看Worker数量，如果Worker数量为0，起一个新的Worker去阻塞队列里拿任务执行 丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法上面说的Worker可以暂时理解为一个执行任务的线程。 execute方法源码如下，上面提到的3个步骤对应源码中的3个注释： 12345678910111213141516171819public void execute(Runnable command) &#123; if (command &#x3D;&#x3D; null) throw new NullPointerException(); int c &#x3D; ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; &#x2F;&#x2F; 第一个步骤，满足线程池中的线程大小比基本大小要小 if (addWorker(command, true)) &#x2F;&#x2F; addWorker方法第二个参数true表示使用基本大小 return; c &#x3D; ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; &#x2F;&#x2F; 第二个步骤，线程池的线程大小比基本大小要大，并且线程池还在RUNNING状态，阻塞队列也没满的情况，加到阻塞队列里 int recheck &#x3D; ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) &#x2F;&#x2F; 虽然满足了第二个步骤，但是这个时候可能突然线程池关闭了，所以再做一层判断 reject(command); else if (workerCountOf(recheck) &#x3D;&#x3D; 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) &#x2F;&#x2F; 第三个步骤，直接使用线程池最大大小。addWorker方法第二个参数false表示使用最大大小 reject(command);&#125; addWorker关系着如何起一个线程，再看addWorker方法之前，先看一下ThreadPoolExecutor的一个内部类Worker, Worker是一个AQS的实现类(为何设计成一个AQS在闲置Worker里会说明)，同时也是一个实现Runnable的类，使用独占锁，它的构造函数只接受一个Runnable参数，内部保存着这个Runnable属性，还有一个thread线程属性用于包装这个Runnable(这个thread属性使用ThreadFactory构造，在构造函数内完成thread线程的构造)，另外还有一个completedTasks计数器表示这个Worker完成的任务数。Worker类复写了run方法，使用ThreadPoolExecutor的runWorker方法(在addWorker方法里调用)，直接启动Worker的话，会调用ThreadPoolExecutor的runWork方法。==需要特别注意的是这个Worker是实现了Runnable接口的，thread线程属性使用ThreadFactory构造Thread的时候，构造的Thread中使用的Runnable其实就是Worker==。下面的Worker的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; &#x2F;** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. *&#x2F; private static final long serialVersionUID &#x3D; 6138294804551838833L; &#x2F;** Thread this worker is running in. Null if factory fails. *&#x2F; final Thread thread; &#x2F;** Initial task to run. Possibly null. *&#x2F; Runnable firstTask; &#x2F;** Per-thread task counter *&#x2F; volatile long completedTasks; &#x2F;** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) *&#x2F; Worker(Runnable firstTask) &#123; &#x2F;&#x2F; 使用ThreadFactory构造Thread，这个构造的Thread内部的Runnable就是本身，也就是Worker。所以得到Worker的thread并start的时候，会执行Worker的run方法，也就是执行ThreadPoolExecutor的runWorker方法 setState(-1); 把状态位设置成-1，这样任何线程都不能得到Worker的锁，除非调用了unlock方法。这个unlock方法会在runWorker方法中一开始就调用，这是为了确保Worker构造出来之后，没有任何线程能够得到它的锁，除非调用了runWorker之后，其他线程才能获得Worker的锁 this.firstTask &#x3D; firstTask; this.thread &#x3D; getThreadFactory().newThread(this); &#125; &#x2F;** Delegates main run loop to outer runWorker *&#x2F; public void run() &#123; runWorker(this); &#125; &#x2F;&#x2F; Lock methods &#x2F;&#x2F; &#x2F;&#x2F; The value 0 represents the unlocked state. &#x2F;&#x2F; The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() !&#x3D; 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125; 接下来看一下addWorker源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;&#x2F; 两个参数，firstTask表示需要跑的任务。boolean类型的core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小&#x2F;&#x2F; 返回值是boolean类型，true表示新任务被接收了，并且执行了。否则是falseprivate boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c &#x3D; ctl.get(); int rs &#x3D; runStateOf(c); &#x2F;&#x2F; 线程池当前状态 &#x2F;&#x2F; 这个判断转换成 rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs !&#x3D; SHUTDOWN || firstTask !&#x3D; null || workQueue.isEmpty)。 &#x2F;&#x2F; 概括为3个条件： &#x2F;&#x2F; 1. 线程池不在RUNNING状态并且状态是STOP、TIDYING或TERMINATED中的任意一种状态 &#x2F;&#x2F; 2. 线程池不在RUNNING状态，线程池接受了新的任务 &#x2F;&#x2F; 3. 线程池不在RUNNING状态，阻塞队列为空。 满足这3个条件中的任意一个的话，拒绝执行任务 if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc &#x3D; workerCountOf(c); &#x2F;&#x2F; 线程池线程个数 if (wc &gt;&#x3D; CAPACITY || wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize)) &#x2F;&#x2F; 如果线程池线程数量超过线程池最大容量或者线程数量超过了基本大小(core参数为true，core参数为false的话判断超过最大大小) return false; &#x2F;&#x2F; 超过直接返回false if (compareAndIncrementWorkerCount(c)) &#x2F;&#x2F; 没有超过各种大小的话，cas操作线程池线程数量+1，cas成功的话跳出循环 break retry; c &#x3D; ctl.get(); &#x2F;&#x2F; 重新检查状态 if (runStateOf(c) !&#x3D; rs) &#x2F;&#x2F; 如果状态改变了，重新循环操作 continue retry; &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop &#125; &#125; &#x2F;&#x2F; 走到这一步说明cas操作成功了，线程池线程数量+1 boolean workerStarted &#x3D; false; &#x2F;&#x2F; 任务是否成功启动标识 boolean workerAdded &#x3D; false; &#x2F;&#x2F; 任务是否添加成功标识 Worker w &#x3D; null; try &#123; final ReentrantLock mainLock &#x3D; this.mainLock; &#x2F;&#x2F; 得到线程池的可重入锁 w &#x3D; new Worker(firstTask); &#x2F;&#x2F; 基于任务firstTask构造worker final Thread t &#x3D; w.thread; &#x2F;&#x2F; 使用Worker的属性thread，这个thread是使用ThreadFactory构造出来的 if (t !&#x3D; null) &#123; &#x2F;&#x2F; ThreadFactory构造出的Thread有可能是null，做个判断 mainLock.lock(); &#x2F;&#x2F; 锁住，防止并发 try &#123; &#x2F;&#x2F; 在锁住之后再重新检测一下状态 int c &#x3D; ctl.get(); int rs &#x3D; runStateOf(c); if (rs &lt; SHUTDOWN || (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123; &#x2F;&#x2F; 如果线程池在RUNNING状态或者线程池在SHUTDOWN状态并且任务是个null if (t.isAlive()) &#x2F;&#x2F; 判断线程是否还活着，也就是说线程已经启动并且还没死掉 throw new IllegalThreadStateException(); &#x2F;&#x2F; 如果存在已经启动并且还没死的线程，抛出异常 workers.add(w); &#x2F;&#x2F; worker添加到线程池的workers属性中，是个HashSet int s &#x3D; workers.size(); &#x2F;&#x2F; 得到目前线程池中的线程个数 if (s &gt; largestPoolSize) &#x2F;&#x2F; 如果线程池中的线程个数超过了线程池中的最大线程数时，更新一下这个最大线程数 largestPoolSize &#x3D; s; workerAdded &#x3D; true; &#x2F;&#x2F; 标识一下任务已经添加成功 &#125; &#125; finally &#123; mainLock.unlock(); &#x2F;&#x2F; 解锁 &#125; if (workerAdded) &#123; &#x2F;&#x2F; 如果任务添加成功，运行任务，改变一下任务成功启动标识 t.start(); &#x2F;&#x2F; 启动线程，这里的t是Worker中的thread属性，所以相当于就是调用了Worker的run方法 workerStarted &#x3D; true; &#125; &#125; &#125; finally &#123; if (! workerStarted) &#x2F;&#x2F; 如果任务启动失败，调用addWorkerFailed方法 addWorkerFailed(w); &#125; return workerStarted; &#125; Worker中的线程start的时候，调用Worker本身run方法，这个run方法之前分析过，调用外部类ThreadPoolExecutor的runWorker方法，直接看runWorker方法： 1234567891011121314151617181920212223242526272829303132333435363738394041final void runWorker(Worker w) &#123; Thread wt &#x3D; Thread.currentThread(); &#x2F;&#x2F; 得到当前线程 Runnable task &#x3D; w.firstTask; &#x2F;&#x2F; 得到Worker中的任务task，也就是用户传入的task w.firstTask &#x3D; null; &#x2F;&#x2F; 将Worker中的任务置空 w.unlock(); &#x2F;&#x2F; allow interrupts。 boolean completedAbruptly &#x3D; true; try &#123; &#x2F;&#x2F; 如果worker中的任务不为空，继续知否，否则使用getTask获得任务。一直死循环，除非得到的任务为空才退出 while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123; w.lock(); &#x2F;&#x2F; 如果拿到了任务，给自己上锁，表示当前Worker已经要开始执行任务了，已经不是闲置Worker(闲置Worker的解释请看下面的线程池关闭) &#x2F;&#x2F; 在执行任务之前先做一些处理。 1. 如果线程池已经处于STOP状态并且当前线程没有被中断，中断线程 2. 如果线程池还处于RUNNING或SHUTDOWN状态，并且当前线程已经被中断了，重新检查一下线程池状态，如果处于STOP状态并且没有被中断，那么中断线程 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); &#x2F;&#x2F; 任务执行前需要做什么，ThreadPoolExecutor是个空实现 Throwable thrown &#x3D; null; try &#123; task.run(); &#x2F;&#x2F; 真正的开始执行任务，调用的是run方法，而不是start方法。这里run的时候可能会被中断，比如线程池调用了shutdownNow方法 &#125; catch (RuntimeException x) &#123; &#x2F;&#x2F; 任务执行发生的异常全部抛出，不在runWorker中处理 thrown &#x3D; x; throw x; &#125; catch (Error x) &#123; thrown &#x3D; x; throw x; &#125; catch (Throwable x) &#123; thrown &#x3D; x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#x2F;&#x2F; 任务执行结束需要做什么，ThreadPoolExecutor是个空实现 &#125; &#125; finally &#123; task &#x3D; null; w.completedTasks++; &#x2F;&#x2F; 记录执行任务的个数 w.unlock(); &#x2F;&#x2F; 执行完任务之后，解锁，Worker变成闲置Worker &#125; &#125; completedAbruptly &#x3D; false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#x2F;&#x2F; 回收Worker方法 &#125;&#125; 我们看一下getTask方法是如何获得任务的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F; 如果发生了以下四件事中的任意一件，那么Worker需要被回收：&#x2F;&#x2F; 1. Worker个数比线程池最大大小要大&#x2F;&#x2F; 2. 线程池处于STOP状态&#x2F;&#x2F; 3. 线程池处于SHUTDOWN状态并且阻塞队列为空&#x2F;&#x2F; 4. 使用超时时间从阻塞队列里拿数据，并且超时之后没有拿到数据(allowCoreThreadTimeOut || workerCount &gt; corePoolSize)private Runnable getTask() &#123; boolean timedOut &#x3D; false; &#x2F;&#x2F; 如果使用超时时间并且也没有拿到任务的标识 retry: for (;;) &#123; int c &#x3D; ctl.get(); int rs &#x3D; runStateOf(c); &#x2F;&#x2F; 如果线程池是SHUTDOWN状态并且阻塞队列为空的话，worker数量减一，直接返回null(SHUTDOWN状态还会处理阻塞队列任务，但是阻塞队列为空的话就结束了)，如果线程池是STOP状态的话，worker数量建议，直接返回null(STOP状态不处理阻塞队列任务)[方法一开始注释的2，3两点，返回null，开始Worker回收] if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; boolean timed; &#x2F;&#x2F; 标记从队列中取任务时是否设置超时时间，如果为true说明这个worker可能需要回收，为false的话这个worker会一直存在，并且阻塞当前线程等待阻塞队列中有数据 for (;;) &#123; int wc &#x3D; workerCountOf(c); &#x2F;&#x2F; 得到当前线程池Worker个数 &#x2F;&#x2F; allowCoreThreadTimeOut属性默认为false，表示线程池中的核心线程在闲置状态下还保留在池中；如果是true表示核心线程使用keepAliveTime这个参数来作为超时时间 &#x2F;&#x2F; 如果worker数量比基本大小要大的话，timed就为true，需要进行回收worker timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize; if (wc &lt;&#x3D; maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)) &#x2F;&#x2F; 方法一开始注释的1，4两点，会进行下一步worker数量减一 break; if (compareAndDecrementWorkerCount(c)) &#x2F;&#x2F; worker数量减一，返回null，之后会进行Worker回收工作 return null; c &#x3D; ctl.get(); &#x2F;&#x2F; 重新检查线程池状态 if (runStateOf(c) !&#x3D; rs) &#x2F;&#x2F; 线程池状态改变的话重新开始外部循环，否则继续内部循环 continue retry; &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop &#125; try &#123; &#x2F;&#x2F; 如果需要设置超时时间，使用poll方法，否则使用take方法一直阻塞等待阻塞队列新进数据 Runnable r &#x3D; timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r !&#x3D; null) return r; timedOut &#x3D; true; &#125; catch (InterruptedException retry) &#123; timedOut &#x3D; false; &#x2F;&#x2F; 闲置Worker被中断 &#125; &#125;&#125; 如果getTask返回的是null，那说明阻塞队列已经没有任务并且当前调用getTask的Worker需要被回收，那么会调用processWorkerExit方法进行回收： 1234567891011121314151617181920212223242526272829303132private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; if (completedAbruptly) &#x2F;&#x2F; 如果Worker没有正常结束流程调用processWorkerExit方法，worker数量减一。如果是正常结束的话，在getTask方法里worker数量已经减一了 decrementWorkerCount(); final ReentrantLock mainLock &#x3D; this.mainLock; mainLock.lock(); &#x2F;&#x2F; 加锁，防止并发问题 try &#123; completedTaskCount +&#x3D; w.completedTasks; &#x2F;&#x2F; 记录总的完成任务数 workers.remove(w); &#x2F;&#x2F; 线程池的worker集合删除掉需要回收的Worker &#125; finally &#123; mainLock.unlock(); &#x2F;&#x2F; 解锁 &#125; tryTerminate(); &#x2F;&#x2F; 尝试结束线程池 int c &#x3D; ctl.get(); if (runStateLessThan(c, STOP)) &#123; &#x2F;&#x2F; 如果线程池还处于RUNNING或者SHUTDOWN状态 if (!completedAbruptly) &#123; &#x2F;&#x2F; Worker是正常结束流程的话 int min &#x3D; allowCoreThreadTimeOut ? 0 : corePoolSize; if (min &#x3D;&#x3D; 0 &amp;&amp; ! workQueue.isEmpty()) min &#x3D; 1; if (workerCountOf(c) &gt;&#x3D; min) return; &#x2F;&#x2F; 不需要新开一个Worker &#125; &#x2F;&#x2F; 新开一个Worker代替原先的Worker &#x2F;&#x2F; 新开一个Worker需要满足以下3个条件中的任意一个： &#x2F;&#x2F; 1. 用户执行的任务发生了异常 &#x2F;&#x2F; 2. Worker数量比线程池基本大小要小 &#x2F;&#x2F; 3. 阻塞队列不空但是没有任何Worker在工作 addWorker(null, false); &#125;&#125; 在回收Worker的时候线程池会尝试结束自己的运行，tryTerminate方法： 123456789101112131415161718192021222324252627282930313233343536final void tryTerminate() &#123; for (;;) &#123; int c &#x3D; ctl.get(); &#x2F;&#x2F; 满足3个条件中的任意一个，不终止线程池 &#x2F;&#x2F; 1. 线程池还在运行，不能终止 &#x2F;&#x2F; 2. 线程池处于TIDYING或TERMINATED状态，说明已经在关闭了，不允许继续处理 &#x2F;&#x2F; 3. 线程池处于SHUTDOWN状态并且阻塞队列不为空，这时候还需要处理阻塞队列的任务，不能终止线程池 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; &#x2F;&#x2F; 走到这一步说明线程池已经不在运行，阻塞队列已经没有任务，但是还要回收正在工作的Worker if (workerCountOf(c) !&#x3D; 0) &#123; &#x2F;&#x2F; 由于线程池不运行了，调用了线程池的关闭方法，在解释线程池的关闭原理的时候会说道这个方法 interruptIdleWorkers(ONLY_ONE); &#x2F;&#x2F; 中断闲置Worker，直到回收全部的Worker。这里没有那么暴力，只中断一个，中断之后退出方法，中断了Worker之后，Worker会回收，然后还是会调用tryTerminate方法，如果还有闲置线程，那么继续中断 return; &#125; &#x2F;&#x2F; 走到这里说明worker已经全部回收了，并且线程池已经不在运行，阻塞队列已经没有任务。可以准备结束线程池了 final ReentrantLock mainLock &#x3D; this.mainLock; mainLock.lock(); &#x2F;&#x2F; 加锁，防止并发 try &#123; if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; &#x2F;&#x2F; cas操作，将线程池状态改成TIDYING try &#123; terminated(); &#x2F;&#x2F; 调用terminated方法 &#125; finally &#123; ctl.set(ctlOf(TERMINATED, 0)); &#x2F;&#x2F; terminated方法调用完毕之后，状态变为TERMINATED termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#x2F;&#x2F; 解锁 &#125; &#x2F;&#x2F; else retry on failed CAS &#125;&#125; 解释了这么多，对线程池的启动并且执行任务做一个总结： 首先，构造线程池的时候，需要一些参数。一些重要的参数解释在 java内置的线程池笔记 文章中的结尾已经说明了一下重要参数的意义。 线程池构造完毕之后，如果用户调用了execute或者submit方法的时候，最后都会使用execute方法执行。 execute方法内部分3种情况处理任务： 如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法 如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步 丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法 线程池中的这个基本大小指的是Worker的数量。一个Worker是一个Runnable的实现类，会被当做一个线程进行启动。Worker内部带有一个Runnable属性firstTask，这个firstTask可以为null，为null的话Worker会去阻塞队列拿任务执行，否则会先执行这个任务，执行完毕之后再去阻塞队列继续拿任务执行。 所以说如果Worker数量超过了基本大小，那么任务都会在阻塞队列里，当Worker执行完了它的第一个任务之后，就会去阻塞队列里拿其他任务继续执行。 Worker在执行的时候会根据一些参数进行调节，比如Worker数量超过了线程池基本大小或者超时时间到了等因素，这个时候Worker会被线程池回收，线程池会尽量保持内部的Worker数量不超过基本大小。 另外Worker执行任务的时候调用的是Runnable的run方法，而不是start方法，调用了start方法就相当于另外再起一个线程了。 Worker在回收的时候会尝试终止线程池。尝试关闭线程池的时候，会检查是否还有Worker在工作，检查线程池的状态，没问题的话会将状态过度到TIDYING状态，之后调用terminated方法，terminated方法调用完成之后将线程池状态更新到TERMINATED。 ThreadPoolExecutor的关闭线程池的启动过程分析好了之后，接下来看线程池的关闭操作： shutdown方法，关闭线程池，关闭之后阻塞队列里的任务不受影响，会继续被Worker处理，但是新的任务不会被接受： 12345678910111213public void shutdown() &#123; final ReentrantLock mainLock &#x3D; this.mainLock; mainLock.lock(); &#x2F;&#x2F; 关闭的时候需要加锁，防止并发 try &#123; checkShutdownAccess(); &#x2F;&#x2F; 检查关闭线程池的权限 advanceRunState(SHUTDOWN); &#x2F;&#x2F; 把线程池状态更新到SHUTDOWN interruptIdleWorkers(); &#x2F;&#x2F; 中断闲置的Worker onShutdown(); &#x2F;&#x2F; 钩子方法，默认不处理。ScheduledThreadPoolExecutor会做一些处理 &#125; finally &#123; mainLock.unlock(); &#x2F;&#x2F; 解锁 &#125; tryTerminate(); &#x2F;&#x2F; 尝试结束线程池，上面已经分析过了&#125; interruptIdleWorkers方法，注意，这个方法打断的是闲置Worker，打断闲置Worker之后，getTask方法会返回null，然后Worker会被回收。那什么是闲置Worker呢？ 闲置Worker是这样解释的：Worker运行的时候会去阻塞队列拿数据(getTask方法)，拿的时候如果没有设置超时时间，那么会一直阻塞等待阻塞队列进数据，这样的Worker就被称为闲置Worker。由于Worker也是一个AQS，在runWorker方法里会有一对lock和unlock操作，这对lock操作是为了确保Worker不是一个闲置Worker。 所以Worker被设计成一个AQS是为了根据Worker的锁来判断是否是闲置线程，是否可以被强制中断。 下面我们看下interruptIdleWorkers方法： 1234567891011121314151617181920212223242526&#x2F;&#x2F; 调用他的一个重载方法，传入了参数false，表示要中断所有的正在运行的闲置Worker，如果为true表示只打断一个闲置Workerprivate void interruptIdleWorkers() &#123; interruptIdleWorkers(false);&#125;private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock &#x3D; this.mainLock; mainLock.lock(); &#x2F;&#x2F; 中断闲置Worker需要加锁，防止并发 try &#123; for (Worker w : workers) &#123; Thread t &#x3D; w.thread; &#x2F;&#x2F; 拿到worker中的线程 if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; &#x2F;&#x2F; Worker中的线程没有被打断并且Worker可以获取锁，这里Worker能获取锁说明Worker是个闲置Worker，在阻塞队列里拿数据一直被阻塞，没有数据进来。如果没有获取到Worker锁，说明Worker还在执行任务，不进行中断(shutdown方法不会中断正在执行的任务) try &#123; t.interrupt(); &#x2F;&#x2F; 中断Worker线程 &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#x2F;&#x2F; 释放Worker锁 &#125; &#125; if (onlyOne) &#x2F;&#x2F; 如果只打断1个Worker的话，直接break退出，否则，遍历所有的Worker break; &#125; &#125; finally &#123; mainLock.unlock(); &#x2F;&#x2F; 解锁 &#125;&#125; shutdown方法将线程池状态改成SHUTDOWN，线程池还能继续处理阻塞队列里的任务，并且会回收一些闲置的Worker。但是shutdownNow方法不一样，它会把线程池状态改成STOP状态，这样不会处理阻塞队列里的任务，也不会处理新的任务： 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F; shutdownNow方法会有返回值的，返回的是一个任务列表，而shutdown方法没有返回值public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock &#x3D; this.mainLock; mainLock.lock(); &#x2F;&#x2F; shutdownNow操作也需要加锁，防止并发 try &#123; checkShutdownAccess(); &#x2F;&#x2F; 检查关闭线程池的权限 advanceRunState(STOP); &#x2F;&#x2F; 把线程池状态更新到STOP interruptWorkers(); &#x2F;&#x2F; 中断Worker的运行 tasks &#x3D; drainQueue(); &#125; finally &#123; mainLock.unlock(); &#x2F;&#x2F; 解锁 &#125; tryTerminate(); &#x2F;&#x2F; 尝试结束线程池，上面已经分析过了 return tasks;&#125;shutdownNow的中断和shutdown方法不一样，调用的是interruptWorkers方法：private void interruptWorkers() &#123; final ReentrantLock mainLock &#x3D; this.mainLock; mainLock.lock(); &#x2F;&#x2F; 中断Worker需要加锁，防止并发 try &#123; for (Worker w : workers) w.interruptIfStarted(); &#x2F;&#x2F; 中断Worker的执行 &#125; finally &#123; mainLock.unlock(); &#x2F;&#x2F; 解锁 &#125;&#125;Worker的interruptIfStarted方法中断Worker的执行：void interruptIfStarted() &#123; Thread t; &#x2F;&#x2F; Worker无论是否被持有锁，只要还没被中断，那就中断Worker if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#x2F;&#x2F; 强行中断Worker的执行 &#125; catch (SecurityException ignore) &#123; &#125; &#125;&#125; 线程池关闭总结： 线程池的关闭主要是两个方法，shutdown和shutdownNow方法。 shutdown方法会更新状态到SHUTDOWN，不会影响阻塞队列里任务的执行，但是不会执行新进来的任务。同时也会回收闲置的Worker，闲置Worker的定义上面已经说过了。 shutdownNow方法会更新状态到STOP，会影响阻塞队列的任务执行，也不会执行新进来的任务。同时会回收所有的Worker。 上一个图： 原文链接：https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/","categories":[],"tags":[]},{"title":"mysql中char和varchar","slug":"mysql中char和varchar","date":"2020-05-16T17:20:11.000Z","updated":"2020-05-16T17:20:33.103Z","comments":true,"path":"2020/05/17/mysql中char和varchar/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/mysql%E4%B8%ADchar%E5%92%8Cvarchar/","excerpt":"","text":"背景 同事在设计表，有一个字段为发票号码，在一般来讲发票号码的长度一般是8位，varchar类型， 他的意思是给20位，我的意思是给少点12位就够了。又因为我们在老的业务里给的是12位，出现过存储的字段过长而导致未能存储的问题。但是解决这个问题的方法是在业务逻辑层做check 然后进行截取（目前我的做法）。因为本来超过了就是不对的，所以这样处理。为何要浪费那个空间呢？？于是又讨论到了varchar在MySQL中的存储方式。，以证明增加长度所占用的空间并不大。那么我们就看看varchar在mysql中到底是如何存储的。 varchar类型在mysql中是如何定义的？先看看官方文档: ==上面是8.0和5.7的文档这个得小心点== 大概意思： char：存储定长数据很方便，CHAR字段上的索引效率级高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不论你存储的数据是否达到了10个字符，都要占去10个字符的空间（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。 varchar：存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。 ALL IN ALL在MySQL数据库中，用的最多的字符型数据类型就是Varchar和Char.。这两种数据类型虽然都是用来存放字符型数据，但是无论从结构还是从数据的保存方式来看，两者相差很大。而且其具体的实现方式，还依赖与存储引擎。我这里就以大家最常用的MYISAM存储引擎为例，谈谈这两种数据类型的差异。在后续建议中，也是针对这种存储类型而言的。 这里首先需要明白的一点是，这两种数据类型，无论采用哪一种存储引起，系统存储数据的方式都是不同的。正是因为如此，我们才有必要研究两者的不同。然后在合适的情况下，采用恰当的方式。了解这一点之后，我们再来看后续的内容。 Varchar往往用来保存可变长度的字符串。简单的说，我们只是给其固定了一个最大值，然后系统会根据实际存储的数据量来分配合适的存储空间。为此相比CHAR字符数据而言，其能够比固定长度类型占用更少的存储空间。不过在实际工作中，由于某系特殊的原因，会在这里设置例外。==如管理员可以根据需要指定ROW_FORMAT=FIXED选项==（innodb的 文档地址：https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html）。利用这个选项来创建MyISAM表的话，系统将会为每一行使用固定长度的空间。此时会造成存储空间的损耗。通常情况下，VARCHAR数据类型能够节约磁盘空间，为此往往认为其能够提升数据库的性能。不过这里需要注意的是，这往往是一把双刃剑。其在提升性能的同时，往往也会产生一些副作用。如因为其长度是可变的，为此在数据进行更新时可能会导致一些额外的工作。如在更改前，其字符长度是10位(Varchar规定的最长字符数假设是50位)，此时系统就只给其分配10个存储的位置(假设不考虑系统自身的开销)。更改后，其数据量达到了20位。由于没有超过最大50位的限制，为此数据库还是允许其存储的。只是其原先的存储位置已经无法满足其存储的需求。此时系统就需要进行额外的操作。如根据存储引擎不同，有的会采用拆分机制，而有的则会采用分页机制。其实也好比我们在Java中使用容器类，为什么在使用的时候需要刚开始位给定一个容器的大小呢？也就是为了防止扩容对性能的消耗。 CHAR数据类型与VARCHAR数据类型不同，其采用的是固定长度的存储方式。简单的说，就是系统总为其分配最大的存储空间。当数据保存时，即使其没有达到最大的长度，系统也会为其分配这么多的存储空间。显然，这种存储方式会造成磁盘空间的浪费。这里笔者需要提醒的一点是，当字符位数不足时，系统并不会采用空格来填充。相反，如果在保存CHAR值的时候，如果其后面有空值，系统还会自动过滤其空格。而在进行数据比较时，系统又会将空格填充到字符串的末尾。 显然，VARCHAR与CHAR两种字符型数据类型相比，最大的差异就是前者是可变长度，而后者则是固定长度。在存储时，前者会根据实际存储的数据来分配最终的存储空间。而后者则不管实际存储数据的长度，都是根据CHAR规定的长度来分配存储空间。这是否意味着CHAR的数据类型劣于VARCHAR呢?其实不然。否则的话，就没有必要存在CHAR字符类型了。虽然VARCHAR数据类型可以节省存储空间，提高数据处理的效率。但是其可变长度带来的一些负面效应，有时候会抵消其带来的优势。为此在某些情况下，还是需要使用Char数据类型。 项目建议 根据上面的分析，我们知道VARCHAR数据类型是一把双刃剑，其在带来性能提升的同时，也可能会存在着一些额外的消耗。我们在评估到底是使用VARCHAR数据类型还是采用CHAR数据类型时，就需要进行均衡。在实际项目中，我们会考量如下情况。 ==是根据字符的长度来判断==。如某个字段，像人的名字，其最长的长度也是有限的。如我们给其分配18个字符长度即可。此时虽然每个人的名字长度有可能不同，但是即使为其分配了固定长度的字符类型，即18个字符长度，最后浪费的空间也不是很大。而如果采用VARCHAR数据类型时，万一以后需要改名，而原先的存储空间不足用来容纳新的值，反而会造成一些额外的工作。在这种情况下，进行均衡时，会认为采用CHAR固定长度的数据类型更好。在实际项目中，如果某个字段的字符长度比较短此时一般是采用固定字符长度。 ==是考虑其长度的是否相近==。如果某个字段其长度虽然比较长，但是其长度总是近似的，如一般在90个到100个字符之间，甚至是相同的长度。此时比较适合采用CHAR字符类型。比较典型的应用就是MD5哈希值。当利用MD5哈希值来存储用户密码时，就非常适合采用CHAR字符类型。因为其长度是相同的。另外，像用来存储用户的身份证号码等等，一般也建议使用CHAR类型的数据。 另外请大家考虑一个问题，CHAR(1)与VARCHAR(1)两这个定义，会有什么区别呢?虽然这两个都只能够用来保存单个的字符，但是VARCHAR要比CHAR多占用一个存储位置。这主要是因为使用VARCHAR数据类型时，会多用1个字节用来存储长度信息(根据开销的大小来判断的)。这个管理上的开销CHAR字符类型是没有的。 ==从碎片角度进行考虑==。使用CHAR字符型时，由于存储空间都是一次性分配的。为此某个字段的内容，其都是存储在一起的。单从这个角度来讲，其不存在碎片的困扰。而可变长度的字符数据类型，其存储的长度是可变的。当其更改前后数据长度不一致时，就不可避免的会出现碎片的问题。故使用可变长度的字符型数据时，数据库管理员要时不时的对碎片进行整理。如执行数据库导出导入作业，来消除碎片。 ==即使使用Varchar数据类型，也不能够太过于慷慨==。这是什么意思呢?如现在用户需要存储一个地址信息。根据评估，只要使用100个字符就可以了。但是有些数据库管理员会认为，反正Varchar数据类型是根据实际的需要来分配长度的。还不如给其大一点的呢。为此他们可能会为这个字段一次性分配200个字符的存储空间。这VARCHAR(100)与VARCHAR(200)真的相同吗?结果是否定的。虽然他们用来存储90个字符的数据，其存储空间相同。但是对于内存的消耗是不同的。对于VARCHAR数据类型来说，硬盘上的存储空间虽然都是根据实际字符长度来分配存储空间的，但是对于内存来说，则不是。==其时使用固定大小的内存块来保存值。简单的说，就是使用字符类型中定义的长度，即200个字符空间。显然，这对于排序或者临时表(这些内容都需要通过内存来实现)作业会产生比较大的不利影响==。所以如果某些字段会涉及到文件排序或者基于磁盘的临时表时，分配VARCHAR数据类型时仍然不能够太过于慷慨。还是要评估实际需要的长度，然后选择一个最长的字段来设置字符长度。如果为了考虑冗余，可以留10%左右的字符长度。千万不能认为其为根据实际长度来分配存储空间，而随意的分配长度，或者说干脆使用最大的字符长度。 所以说：刚invoiceNo设置为char类型 切设置为12个字节大小。拓展： 还有就是我们在使用索引的时候，在插入和更新的时候使用的是指定的长度还是正式字符的长度？？？？我给自己留个问好？ 竟然创建成功了。看了下是自动截取了255个字符。所以没能验证成功，本以为是因为innoDB 中索引的字段长度不能超过767个字节，如果是按照预先给的长度的话肯定会创建失败的。但是现在他是自动截取到了255，但是里面给的字段是不到255的，所以是可以证明是按照预先给的来决定的。 然后我有给了char（254）仍然是直接成功，查看了索引的字节数感觉有点对不上，明天再看看","categories":[],"tags":[]},{"title":"JVM线上内存问题排查","slug":"JVM线上内存问题排查","date":"2020-05-16T17:16:23.000Z","updated":"2020-05-16T17:17:15.824Z","comments":true,"path":"2020/05/17/JVM线上内存问题排查/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/JVM%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/","excerpt":"","text":"背景：正在和同事在外面吃饭，突然钉钉报警，有一个服务的机器内存飙到百分之90%多。和同事大概聊了一下说是队列累积，机器消费不过来，具体原因也没有深问，又一同事，说看一下是那个对象占的内存，使用jmap，jstat。当时我也在旁边围观，由于之前有看过，我就说jmap在生产环境敢使用吗？ jmap，jstat的作用？ jmap 是内存影像工具，jmap用于生成堆转储快照（一般称为dump或者heapdump文件）也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。 使用参数 1-XX:+HeapDumpOnOutOfMemoryError ，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件使用参数 1-XX:+HeapDumpOnCtrlBreak 然后使用 Ctrl+Break 生成在 Linux 系统中使用 kill -3 发送进程退出信号“吓唬”虚拟机，让其生成 dump 文件） 2. jstat (JVM statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具他可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据，在没有GUI图形界面 ,只提供了纯文本控制台环境的服务器上，他是运行期定位虚拟机的首选工具（周志明说） jmap实战[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lQojpBgg-1587553128990)(CF4BE02FA6C941DEB23E041B50C4FAE7)] 首先我们使用jps命令查看当前运行在JVM上的应用的LVMID也就是我上图的28398 拿到这个后使用jmap -dump命令1jmap -dump:format&#x3D;b,file&#x3D;dumpHeap.bin 28398 执行成功后使用ll就可以看到dump 下来的文件 接下来我们可以使用其他的分析工具进行分析 如：jhat ，Visual VM，MAT等。周志明说：能用其他工具就不要用jhat原因是：一般不会在部署应用的服务器上进行分析dump文件，分析dump文件是一件非常耗费硬件资源的过程，第二个原因就是jhat很简陋。所以还是使用将多个功能放在一块的工具Visual VM来进行分析。 Tips : 但是这个dump在生产环境中还是慎用，因为在dump文件的过程中为保证文件的准确性会停止所有的进程的（个人觉得有点类似于gc 中的stop the word） jstat 实战 jps获取服务的LVMID jstat -gc 我们从图中可以观察到 其中 S0 和 S1 指 Survivor0 区和 Survivor1区，E 即 Eden 区，O 指老年代，M 指 MetaSpace，元数据空间，CCS 是压缩使用比例，YGC：年轻代垃圾回收次数，FGC：老年代垃圾回收次数，FGCT：老年代垃圾回收消耗时间，GCT：垃圾回收消耗总时间。当我们拿到了生产上的信息，且进行了分析，那我们就得查看现有的配置。那就是用jinfo jinfo实战 不管怎样我们都得查找到LVMID 通过jinfo查看得到该应用程序的现有配置。 或者说我们使用的jekins自动化构建工具那我们可以在 1cd &#x2F;usr&#x2F;local&#x2F;deploy&#x2F;supervisord&#x2F;conf&#x2F;项目对应的conf文件 cat 文件进行查看 应用的启动配置的配置文件。其实不是不可以使用jmap而是jmap -dump的使用的时候需要注意。有可能会导致服务停止！！","categories":[],"tags":[]},{"title":"请分清楚Java内存区域和Java内存模型","slug":"请分清楚Java内存区域和Java内存模型","date":"2020-05-16T17:14:49.000Z","updated":"2020-05-16T17:15:12.464Z","comments":true,"path":"2020/05/17/请分清楚Java内存区域和Java内存模型/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/%E8%AF%B7%E5%88%86%E6%B8%85%E6%A5%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"java内存区域是java虚拟机在执行java程序的时候会把它所管理的内存进行划分不同的数据区域。但是java内存模型是为了屏蔽各种硬件和操作系统的内存访问的差异，已实现java程序在不同的操作系统中都能达到一致的访问效果 Java内存区域1. 线程共享区： 堆：堆可分为eden区和survior to和survior from 区 刚创建的对象，且堆内存够放下这个对象，都会放在eden区。 方法区： 存储已经被加载的类信息，常量，静态变量，即时编译后的代码等数据。在hotspot虚拟机中方法区也被称为老年代。 2. 线程独享区 Java虚拟机栈：在我们代码在运行是调用一个方法就会创建一个栈帧用于存储局部变量表，动态链接，操作数栈，方法出口等。调用方法的过程也就是压栈和弹栈的过程，栈的数据结构是先进后出的我们可以想一下主方法调用其他方法，其他方法调用完成那其他的方法就弹栈了谈完后其以及已经将动态链接的数据已经改变，于是你的主方法内的数据也随即改变。仔细品品。 本地方发栈： 本地方法栈和Java虚拟机栈的作用类似，Java虚拟机栈是为java方法的使用而执行的，但是本地方法栈是为了Java虚拟机调用的native方法执行的。正是因为本地方法栈不会限制使用的语言，使用的方法还有数据结构。 程序计数器：粗糙一点也就是为了记录代码执行到那一块了。还有就是我们在执行多线程的时候，在虚拟机中并不是所谓的同步执行的，而是通过线程的切换并分配处理器的时间的方式来实现的，所以在切换的过程中有的线程执行了一半，又切换到了其他线程那就得将其字节码指令执行到那一块就得记录下来，这也是程序计数器为什么是私有的原因。 3. 直接内存（非Java虚拟机中运行时动态区域，但是也会引起OOM） 直接内存并不属于JVM动态运行时区域，我们在使用NIO的时候基于通道与缓冲区的方式（buffer）的I/O的方式，他可以使用native函数库直接分配堆外内存 ，然后通过存储在Java堆种的dirctyByteBuffer对象作为这块堆内存的一面用进行操作。java内存模型 Java的内存模型重要的目标是定义程序中的各个变量的访问规则。即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处变量只是针对全局变量和静态字段，和构成数组的对象元素。 Java的内存模型分为 主内存，工作内存。 工作内存：每一个线程都拥有自己的工作内存，工作内存保存的是从主内存复制拷贝过来的副本,不同的线程之间是不可以直接进行工作内存的访问，必须通过主内存作为中间人才可以访问。 主内存：主内存就用来存放所有的公共变量。线程间可以共享的变量。 Java内存模型和Java运行时动态内存模型类比的话，那么主内存就是其Java堆中的那些对象实例，而工作内存区域就是Java虚拟机栈中的局部变量表还有refrence所指向的数据，还有方法参数等。思考一下 volatile关键字是如何达到变量在各个线程间是可见的呢？","categories":[],"tags":[]},{"title":"微观经济学和宏观经济学","slug":"微观经济学和宏观经济学","date":"2020-05-16T17:13:36.000Z","updated":"2020-05-16T17:13:50.864Z","comments":true,"path":"2020/05/17/微观经济学和宏观经济学/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%92%8C%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/","excerpt":"","text":"什么是微观经济学？ 微观经济学又称个体经济学，小经济学，是宏观经济学的对称。微观经济学主要以单个经济单位(单个的生产者、单个的消费者、单个市场的经济活动)作为研究对象，分析单个生产者如何将有限的资源分配在各种商品的生产上以取得最大的利润；单个消费者如何将有限的收入分配在各种商品的消费上以获得最大的满足。同时， 微观经济学还分析==单个生产者的产量、成本、使用的生产要素数量和利润如何确定==；生产要素供应者的收入如何决定；单个商品的效用、供给量、需求量和价格如何确定等等。 微观经济学 ——分析个体经济单位的经济行为,在此基础上,研究现代西方经济社会的市场机制运行及其在经济资源配置中的作用,并提出微观经济政策以纠正市场失灵。 微观经济学关心社会中的个人和各组织之间的交换过程，它研究的基本问题是资源配置的决定，其基本理论就是通过供求来决定相对价格的理论。所以微观经济学的主要范围包括消费者选择，厂商进行的供给和收入分配。 微观”是希腊文“ μικρο ”的意译，原意是“小”。微观经济学是研究社会中单个经济单位的经济行为，以及相应的经济变量的单项数值如何决定的经济学说。亦称市场经济学或价格理论。微观经济学的中心理论是价格理论。微观经济学的一个中心思想是，自由交换往往使资源得到最充分的利用，在这种情况下，资源配置被认为是帕累托（Pareto） 有效的。 总结一下：通俗来讲微观经济学就是研究让一个个体或者一个组织来的利益最大化。将其现有资源最大化使用。也就是我们接下来要说的： 微观经济学的研究方向 微观经济学研究市场中个体的经济行为，亦即单个家庭、单个厂商和单个市场的经济行为以及相应的经济变量数值的决定。 ==它从资源稀缺这个基本概念出发，认为所有个体的行为准则在于设法利用有限的资源取得最大的收获，并由此来考察个体取得最大收获的条件==。（感觉很适合目前“资源稀缺”的我） 在商品与劳务市场上，作为消费者的家庭根据各种商品的不同价格进行选择，==设法用有限的收入从所购买的各种商品量中获得最大的效用或满足==（这也就是我们平时所说的性价比，让你所买的东西性价比达到最高）。家庭选择商品的行动必然会影响商品的价格，市场价格的变动又是厂商确定生产何种商品的信号。 厂商是各种商品及劳务的供给者，厂商的目的则在于如何用最小的生产成本，生产出最大的产品量，获得取最大限度的利润。厂商的抉择又将影响到生产要素市场上的各项价格，从而影响到家庭的收入。家庭和厂商的抉择均通过市场上的供求关系表现出来，通过价格变动进行协调。因此，微观经济学的任务就是研究==市场机制及其作用，均衡价格的决定，考察市场机制如何通过调节个体行为取得资源最优配置的条件与途径==。微观经济学也就是关于市场机制的经济学，它以价格为分析的中心，因此也称作价格理论。 微观经济学还考察了市场机制失灵时，政府如何采取干预行为与措施的理论基础（就在最近疫情，政府的贷款利率降低，向民众发放优惠券等）。 微观经济学是马歇尔的均衡价格理论基础上，吸收美国经济学家张伯仑和英国经济学家罗宾逊的垄断竞争理论以及其他理论后逐步建立起来的。凯恩斯主义的宏观经济学盛行之后，这种着重研究个体经济行为的传统理论，就被称为微观经济学。微观经济学与宏观经济学的区别 了解了微观经济学后，那宏观经济学呢？（已经明确：主要还是学习微观经济学） 二者的区别主要表现在： （1）==研究对象不同==。微观经济学的研究对象是单个经济单位，如家庭、厂商等。正如美国经济学家J亨德逊（JHenderson）所说居民户和厂商这种单个单位的最优化行为奠定了微观经济学的基础。而宏观经济学的研究对象则是整个经济，研究整个经济的运行方式与规律，从总量上分析经济问题。正如萨缪尔逊所说，宏观经济学是根据产量、收入、价格水平和失业来分析整个经济行为。美国经济学家E夏皮罗（EShapiro）则强调了宏观经济学考察==国民经济作为一个整体的功能==。 （2）==解决的问题不同==。==微观经济学要解决的是资源配置问题==，即生产什么、如何生产和为谁生产的问题，以实现个体效益的最大化。宏观经济学则把资源配置作为既定的前提，==研究社会范围内的资源利用问题，以实现社会福利的最大化==。 （3）==研究方法不同==。微观经济学的研究方法是个量分析，即研究经济变量的单项数值如何决定。而宏观经济学的研究方法则是总量分析，即对能够反映整个经济运行情况的经济变量的决定、变动及其相互关系进行分析。这些总量包括两类，一类是个量的总和，另一类是平均量。因此，宏观经济学又称为总量经济学。 （4）==基本假设不同==。","categories":[],"tags":[]},{"title":"阿里代码规约为什么不让使用Executors包装好线程池呢","slug":"阿里代码规约为什么不让使用Executors包装好线程池呢","date":"2020-05-16T17:09:33.000Z","updated":"2020-05-16T17:09:55.067Z","comments":true,"path":"2020/05/17/阿里代码规约为什么不让使用Executors包装好线程池呢/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%AE%A9%E4%BD%BF%E7%94%A8Executors%E5%8C%85%E8%A3%85%E5%A5%BD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%A2/","excerpt":"","text":"在Executors下主要有5个静态方法：1. Executors.newWorkStealingPool JDK8引入，创建持有足够线程的线程池支持给定的并行度，并通过使用多个队列减少竞争，此构造方法把CPU数量设置为默认的并行度 1234567891011public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode) &#123; this(checkParallelism(parallelism), checkFactory(factory), handler, asyncMode ? FIFO_QUEUE : LIFO_QUEUE, &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;); checkPermission();&#125; 2. Executors.newCacheThreadPool 这个线程池是一个没有核心线程数的，且最大线程数是Integer.MAX_VALUE，且使用的队列是SynchronousQueue，这个队列有点反人类，他不存储元素的阻塞队列，在创建元素的时候每一个put操作必须等待take操作，否则就不能添加元素 。这样我们就知道了因为没有核心线程数，所以刚来的任务我们都会进入到队列中，但是这个队列没有take也不会put，此时那就是说队列满了，然后就创建最大线程数。且设置的最大线程数在空闲状态下的存活时间为60秒。当有线程闲下来的时候，如果有新的任务来的时候就是用空闲线程，但是有可能出现瞬间来了大量的请求，此时就会无限创建线程直到Integer.MAX_VALUE个线程，很多机器应该在没有达到之前就会OOM了。创建一个线程就会分配堆，本地方法栈，java虚拟机栈等。所以就很容易就OOM了 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 3. Executors.newScheduledThreadPool 线程数最大到Integer.MAX_VALUE,与上面所说的一样都有可能会OOM，他是ScheduledExecutorService接口家族的实现类，支持定时及周期性任务执行。与newCacheThreadPool的区别就是不回收工作线程。从下面代码可以看出到最后也是使用了ThreadPoolExcutor这个类然定义了对应对参数。如设置了最大线程数的存活时间是0秒。1234567891011121314151617public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 4. Executors.newSingleThreadExecutor 创建一个单线程的的线程池，相当于单线程串行执行任务，保证按任务的提交顺序依次执行。这个线程池虽然不会因为线程创建过多而oom但是会因为阻塞到队列而最后产生oom，因为他使用的是LinkedBlockingQueue 看源码我们可知他的最大长度也是Integer.MAX_VALUE，所以大量任務的提交也会导致OOM。 源码： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 5. Executors.newFixedThreadPool 输入的参数即是固定的线程数，即是核心的线程数也是最大的线程数，不存在空闲线程 看下面的源码我们可知最大线程数和核心线程数是相等的，也就可说只有核心线程数，我们都知道如果核心线程数没有特定的配置的话核心线程数一旦创建就不会被回收的。但是我们可以看到他使用的也是LinkedBlockingQueue且默认的大小为Integer.MAX_VALUE，所以也会OOM。12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 其实看了上面的Excutors的五个方法后，在阿里规约里面时不可以使用除第一个外的四个包内线程的，因为他们都会引起OOM。==从源码我们可以看出都是有ThreadPoolExcutor这个类传入不同的参数而实现的所以说只要我们搞懂其中传入的7个参数的含义，就可以大概搞懂线程池的冰山一角了==","categories":[],"tags":[]},{"title":"中流砥柱java的动态代理","slug":"day01","date":"2020-05-16T16:59:36.000Z","updated":"2020-05-23T08:58:58.042Z","comments":true,"path":"2020/05/17/day01/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/day01/","excerpt":"","text":"背景在我们学习Spring框架的时候我们是否思考过，Spring是如何实现bean实列注入到IOC容器中呢？我们如何去 权威指南代理是基本的设计模式之一，他是为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理通常充当着中间人的角色。Java的动态代理比代理的思想更迈进了一步，因为他可以动态地创建代理并动态的处理对所代理的方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，他的工作是揭示调用的类型并确定相应的对策。 ——-《ThinKing in Java》 个人理解 类比生活代理，平时生活中代理无处不在，如手机生产商的代理商A，A不仅能帮忙给生产商卖手机而且也提供了售后功能。代码中被代理对象就是生产商，而代理商A就是代理对象，可以做生产商的事情，为了方便客户还提供了售后的功能。但是此时这个生产商不固定，且随时会变，且为了利益最大化，那个生产商拿货便宜，就拿谁的货，就在这个时候我们是不是就得成为一个动态代理商？这样就可以方便用户，还能和生产商解耦合。 抽象层面将一个对象被另一个对象代理，代理对象可以扩展被代理对象的方法，且能在被代理对象对象增加方法。这样实现好之后我们所代理的对象会在编译和累加载之后将带代理对象和被代理对象绑定到一块了。为了让代理更加方便和实用于是就得出了动态代理，也就是再程序运行时可以根据被代理对象生成代理对象。（在java中反射机制就是可以让代码进行动态加载和生成对象）jdk动态代理 JDK的动态代理也就是基于Java的反射机制实现的。 我们先来看一下Java中的动态代理在代码中是如何实现的： 12345678910111213141516171819202122232425262728293031323334353637383940package dynamicproxy;import java.lang.reflect.*;&#x2F;** * @Author:yuanxindong * @Date:2020&#x2F;5&#x2F;90:53 *&#x2F;public class Client &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; &#x2F;&#x2F;实例化一个对象 &#x2F;&#x2F;分别分为两种方事实现的，一个是直接new 关键字创建一个对象， &#x2F;&#x2F; 第二种是通过反射机制穿件一个对象 &#x2F;&#x2F;UserServiceImpl userServiceLmpl &#x3D; new UserServiceImpl(); &#x2F;&#x2F;1。 读取加载&quot;dynamicproxy.UserServiceImpl&quot;路径下的class对象 Class aClass &#x3D; Class.forName(&quot;dynamicproxy.UserServiceImpl&quot;); &#x2F;&#x2F;使用class对象中的方法获取父类加载器 &#x2F;&#x2F;ClassLoader classLoader &#x3D; userServiceLmpl.getClass().getClassLoader(); ClassLoader classLoader &#x3D; aClass.getClassLoader(); &#x2F;&#x2F;Class [] interfaces &#x3D; userServiceLmpl.getClass().getInterfaces(); &#x2F;&#x2F;获取实现class实现的接口 Class[] interfaces &#x3D; aClass.getInterfaces(); &#x2F;&#x2F;获取这个类的、构造方法 Constructor constructors &#x3D; aClass.getConstructor(); &#x2F;&#x2F;通过构造方法 去实例化这个对象 UserServiceImpl userServiceLmpl &#x3D; (UserServiceImpl) constructors.newInstance(); &#x2F;&#x2F;将获取到的对象传入对应的处理器上，通过反射的方式拿到对应的方法切织入 InvocationHandler logHandler &#x3D; new LogHandler(userServiceLmpl); &#x2F;&#x2F;创建动态代理对象的接口 UserService proxy &#x3D; (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler); proxy.select(); proxy.update(); ProxyUtils.generateClassFile(userServiceLmpl.getClass(), &quot;UserServiceProxy&quot;); &#125;&#125; 被代理的对象 12345678&#x2F;** * @Author:yuanxindong * @Date:2020&#x2F;5&#x2F;90:56 *&#x2F;public interface UserService &#123; public void select(); public void update();&#125; 123456789101112131415161718192021222324252627282930313233package dynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;&#x2F;** * @Author:yuanxindong * @Date:2020&#x2F;5&#x2F;90:47 *&#x2F;public class LogHandler implements InvocationHandler &#123; private Object target; &#x2F;&#x2F;使用构造方法将代理对象传入代理对象 public LogHandler(Object target)&#123; this.target &#x3D; target; &#125; &#x2F;&#x2F;通过反射的方式执行并织入（不知道用的是否合理）代理方法，这个接口实现方法会被newProxyInstance（）方法使用 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); &#x2F;&#x2F; Object result &#x3D; method.invoke(target,args); after(); return result; &#125; private void before()&#123; System.out.println(&quot;log start&quot;+ System.currentTimeMillis()); &#125; private void after()&#123; System.out.println(&quot;log end&quot; + System.currentTimeMillis()); &#125;&#125; 执行结果： demo中的InvocationHandler 从demo中看我们将代理对象的其他方法是在实现InvocationHandler的类中写的，通过实现的invoke（）方法将被代理类织入代理类的方法中 然后在newProxyInstance（）方法中实例化这个 invoke（）方法成为代理对象。如下面的源码所示：总结jdk的动态代理通过Java反射机制实现主要的方法是： 实现被代理的方法：继承InvocationHandler接口 实现其invoke方法 1InvocationHandler logHandler &#x3D; new LogHandler(userServiceLmpl); 使用Proxy.newProxyInstance(classLoader, interfaces, logHandler)，创建代理对象。 1UserService proxy &#x3D; (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler); 思考 Spring AOP是怎样实现的呢？？ 也是像我们上面的方法那样织入的吗？？？","categories":[],"tags":[]},{"title":"Java中是否直接可以使用enum进行传输","slug":"Java中是否直接可以使用enum进行传输","date":"2020-05-16T16:41:38.000Z","updated":"2020-05-16T17:01:25.773Z","comments":true,"path":"2020/05/17/Java中是否直接可以使用enum进行传输/","link":"","permalink":"http://www.yuanxindong.com/2020/05/17/Java%E4%B8%AD%E6%98%AF%E5%90%A6%E7%9B%B4%E6%8E%A5%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8enum%E8%BF%9B%E8%A1%8C%E4%BC%A0%E8%BE%93/","excerpt":"","text":"背景我们在进行传输的时候 会有一些状态值，如Status为1代表删除，为0代表失败或者怎么样的。只传输一个）0或者1过去给第三方（此处不包括给前端），如果没有契约第三方会不认识你这个是什么意思，那我们在平时写业务逻辑的时候使用枚举很轻易就知道了什么状态什么值。所以我们在构建DTO对象的时候里面放一个枚举来表示。 ==首先在阿里的规范里是这样说的：【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。==那到底为啥不能用呢？ 枚举 首先我们得先思考一下枚举是否可以进行序列化，我们在把对象进行传输的时候需要将这个对象序列化为字节序列进行传输（在linux中一切皆文件，JVM虚拟机将对象变为字节给到内核通过传输协议进行打包传）枚举在进行编译后会生成一个相关的类，这个类，这个类继承了JavaAPI中的java.lang.Enum类。那么我们看看这个类，毫无疑问可以序列化。继承了Serializable接口。那么就肯定就是可以序列化了。Enum实战序列化 创建一个枚举类1234567891011121314151617181920package SerializableEnum;&#x2F;** * @Author:yuanxindong * @Date:2020&#x2F;5&#x2F;101:33 *&#x2F;public enum PersonEnum &#123; &#x2F;** * 小圆 *&#x2F; YUANXINDONG(&quot;yuanxindong&quot;,1); ; private String age; private int i; PersonEnum(String yuanxindong, int i) &#123; this.age &#x3D; yuanxindong; this.i &#x3D; i; &#125;&#125; 2.将枚举类放入Person对象，通过本地序列化存入target文件夹中，再进行反序列化，读取查看枚举的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package SerializableEnum;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;&#x2F;** * @Author:yuanxindong * @Date:2020&#x2F;5&#x2F;101:31 *&#x2F;public class Person implements Serializable &#123; private String name; PersonEnum a; public void setName(String name) &#123; this.name &#x3D; name; &#125; public void setA(PersonEnum a) &#123; this.a &#x3D; a; &#125; public String getName() &#123; return name; &#125; public PersonEnum getA() &#123; return a; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, a&#x3D;&quot; + a + &#39;&#125;&#39;; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;object.txt&quot;)); Person p &#x3D; new Person(); p.setA(PersonEnum.YUANXINDONG); p.setName(&quot;小圆&quot;); oos.writeObject(p); ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;D:\\\\workCode\\\\票税助手\\\\aresV3\\\\springCodestudy\\\\object.txt&quot;)); Person brady &#x3D; (Person) ois.readObject(); brady.getA(); System.out.println(brady); &#125;&#125; 执行结果：但是在控制台输出的对象是枚举的命名，没有枚举中的值，这时为什么呢？我用的是aliFastJson转还为JsonObject的我们看看他里面的实现。只是拿了对应枚举的name（感觉是个坑啊），这也阿里规范中不能使用枚举放在DTO的原因之一吧==上面的内容整明了枚举是可以进行序列化的，是可以被传输的，他的实现也是通过类来实现的，除了fastJSON那一步，使用都没有问题的。其他角度考虑 借鉴知乎 使用枚举的确会带来扩展兼容性的问题，这点很多答主都说的很好了，我就说一下为什么参数上可以使用枚举的原因吧。咱们先假定对枚举的扩展只是新增值，而不是减少值。比如说性别中本来是男和女，现在要增加一个transgender, 但我们极少极少会有需求说，把性别中的已有男或者女去掉。（我觉得这个假设是参数可以使用枚举型的前提）在这个假定下如果我们在接口中使用枚举型，如孤尽兄在java开发手册中所述，分为参数和返回值两种情况。不管是微服务之间的互相调用，还是手机客户端到服务器的调用，在不停机的情况下，服务器端和客户端是很难一起更新的，往往我们是服务器端先来支持新feature，然后再来逐步更新客户端。我想孤尽兄说参数可以使用枚举型，也是基于这种更新升级方式。因为服务器端如果突然开始返回transgender这个新性别，客户端吃不进去（反序列化不了），客户端就炸了。但如果服务器端只是在参数上开始接受新性别，那就不怕老客户端，反正老客户端还在那里继续发送男和女这两种性别，服务器端都认识，就不会出错。两边可以一直相安无事，慢慢等所有客户端都升级。但是呢，如果我们用string来代替枚举，服务器端贸然返回一个新的值，客户端不知道怎么处理，也可能会产生其他问题，比如说钱算错了之类业务层面的问题。所以客户端代码可能要先更新一点，让其能处理这个新的值。我觉得阿里把这个标准放在手册里，也是多年的经验教训，两害相权取其轻吧。因为很多应用是没法强制客户端一起更新的。尤其是手机移动客户端，ios可能还要审核，很难做到客户端和服务器端同步更新。如果是微服务，也很难在不停机的情况下，把通过枚举耦合两个微服务一起更新。 看完大佬的说法个人感觉：是的你在一个项目中维护是没有什么问题。但是多个项目使用同一个枚举怎么搞。要么这个枚举一处动即全动。所有的项目使用这一个枚举。比如说全公司有一个通用的发票类型枚举，有几个状态值代表一钟发票类型，于是这个枚举维护到公共配置上，通过动态加载技术，在每次发布或者有修改的时候进行动态加载。感觉同完美。小白的YY。落地难吗？？试一试。后面更新.","categories":[],"tags":[]},{"title":"java的反射机制到底是做什么的？","slug":"article-title","date":"2020-05-16T12:02:57.000Z","updated":"2020-05-16T14:54:24.469Z","comments":true,"path":"2020/05/16/article-title/","link":"","permalink":"http://www.yuanxindong.com/2020/05/16/article-title/","excerpt":"","text":"背景在学习java的动态代理的时候用到了反射机制，那我们来对反射机制深入了解一下 权威指南通过wiki百科可知： 在计算机学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。[1]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 在类型检测严格的面向对象的编程语言如Java中，一般需要在编译期间对程序中需要调用的对象的具体类型、接口、字段和方法的合法性进行检查。反射技术则允许将对需要调用的对象的信息检查工作从编译期间推迟到运行期间再现场执行。这样一来，可以在编译期间先不明确目标对象的接口名称、字段（fields，即对象的成员变量）、可用方法，然后在运行根据目标对象自身的信息决定如何处理。它还允许根据判断结果进行实例化新对象和相关方法的调用。 个人理解在一般情况下， 文件会在编译期转换为jvm可执行的字节码 .class 文件，这个执行过程是在类加载的时候执行的，但是jvm在类加载对这一过程并不严格，所以说这一加载步骤可以放在运行期执行。利用这一特性也就有了反射机制。 反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。 我感觉还有有点“干” ,反射也是创建对象的一种方式，使用new 关键字可以创建一个对象，那是因为我们知道他是个什么对象，而反射反射的意思是，我并不知道这个对象是什么，但是我可以通过class.forName()读取到这个对象，然后也可以读取到他的Method ，interface ，Construct等，还可以通过Invoke（）方法进行赋值等操作。 java中反射的使用 写一个demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;&#x2F;** * @Author:yuanxindong * @Date:2020&#x2F;5&#x2F;1113:23 *&#x2F;public class Person extends Huaman&#123; private String name; private String gender; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender &#x3D; gender; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, gender&#x3D;&#39;&quot; + gender + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; &#x2F;&#x2F;通过classLoad 获取类的 Class 对象实例。 Class c &#x3D; Class.forName(&quot;reflect.Person&quot;); &#x2F;&#x2F;根据Class对象实例获取 Constructor 对象 Method setName &#x3D; c.getMethod(&quot;setName&quot;, String.class); &#x2F;&#x2F;根据 Class 对象实例获取 Constructor 对象 Constructor constructor &#x3D; c.getConstructor(); &#x2F;&#x2F;使用Constructor对象的newInstance 方法获取反射类对象 Object o &#x3D; constructor.newInstance(); &#x2F;&#x2F;使用invoke方法调用创建实例对象的方法。 setName.invoke(o,&quot;yuanxindong&quot;); &#x2F;&#x2F;查看调用是否成功 System.out.println(o.toString()); &#125;&#125; 下面是执行结果。 ==上面的代码就可以看出来java中的反射基础使用，但是一个new关键字和直接一个set方法就能解决的问题为什么，非要使用反射呢？== 先明确一点，反射直接根据文件的地址获取class，将其加载到内存中 。不需要在刚开始进行编译，直接在运行期间进行读取加载。 这就是他的优势，我们使用new关键字这个类必须是被预先被加载过的，我们可以大概看一forName（）的源码：其中的classLoad也就是父类加载器，我们在这里就先证明他就是去加载class对象了。（具体不在这里细究）。如果是使用new 关键字的话那么这个对象前提得是被解析过的（加载，验证，初始化和卸载这五个阶段顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段却不一定：他在某些情况下可以在初始化之后再开始《深入理解java虚拟机》） 再者就是Java反射现在应用的场景， JDBC的数据库连接 Spring 框架的使用 将程序内所有 XML 或 Properties 配置文件加载入内存中Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息 使用反射机制，根据这个字符串获得某个类的Class实例 再在这里扯一下Spring为什么这么做呢？他的意思就是遵循“好莱坞规则”我不去找你，而是我来找你。也就是IOC和DI的意思，将对象创建好注入到IOC容器再使用依赖注入的方式主动注入到对应的类中。总结说了上面那么一大堆，也不知道吧反射机制说清楚没有，java的反射的目的就是在==运行时期动态加载class对象==和==实例化对象==,主要使用的方法有： 12345Class.forName();class.getMethod();class.getConstructor();constructor.newInstance();method.invoke(Object,value); 思考我们在使用携程的文件配置系统 APollo的时候，他是如何达到更改配置后达到热更新的？是否基础原理也是用到了反射？？","categories":[],"tags":[]}],"categories":[],"tags":[]}