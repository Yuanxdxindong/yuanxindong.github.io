<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Welcome to Jeff&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome to Jeff&#39;s blog">
<meta property="og:url" content="https://yuanxdxindong.github.io/yuanxindong.github.io/index.html">
<meta property="og:site_name" content="Welcome to Jeff&#39;s blog">
<meta property="og:description" content="java">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yuanxindong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/yuanxindong.github.io/atom.xml" title="Welcome to Jeff&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/yuanxindong.github.io/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/yuanxindong.github.io/" id="logo">Welcome to Jeff&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/yuanxindong.github.io/" id="subtitle">study&amp;Live</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/yuanxindong.github.io/">Home</a>
        
          <a class="main-nav-link" href="/yuanxindong.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/yuanxindong.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yuanxdxindong.github.io/yuanxindong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-以正确姿势理解区块链技术？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/%E4%BB%A5%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E7%90%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/" class="article-date">
  <time datetime="2020-05-17T05:20:13.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/%E4%BB%A5%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E7%90%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/">以正确姿势理解区块链技术？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天在看了一个视频《全球区块链全球生态技术大会》中的腾讯云通过区块链技术实现了一个针对于企业服务的Tbaas区块链基础服务平台。（视频地址:<a href="https://note.youdao.com/" target="_blank" rel="noopener">https://time.geekbang.org/dailylesson/detail/100016514</a>），之前因比特币看过区块链这方面的技术，大概了解了一下区块链技术的中心思想。今天看一下我们目前区块链技术的落地方案。</p>
<h3 id="什么是区块链技术？"><a href="#什么是区块链技术？" class="headerlink" title="什么是区块链技术？"></a>什么是区块链技术？</h3><h4 id="权威指南"><a href="#权威指南" class="headerlink" title="权威指南"></a>权威指南</h4><p>wiki百科：<em>区块链（英语：blockchain[1][2][3]或block chain[4][5]）是借由密码学[1][6]串接并保护内容的串连文字记录（又称区块）。<br>每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易数据（通常用默克尔树(Merkle tree)算法计算的散列值表示）[7]，这样的设计使得区块内容具有难以篡改的特性。用区块链技术所串接的分布式账本能让两方有效纪录交易，且可永久查验此交易。</em></p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>区块链技术的目的是实现去中心化（弱中心化），为什么去中心化。因为去了中心化就不用某一个中心化用户来维护这份“账本数据”，可以动员所有的用户去维护这个账本（或联盟成员），这样可以让账本数据更加的透明化（可信任）。这些用户可以通过POW算法（分布式一致性算法）去维护这个帐本。这个账本之间都是依次相互联系的，通过加密算法进行账本间的相互依赖也就是可溯源。</p>
<p>我们再想想，比特币的初衷是去中心化，不再再去受某个机构或某个团体的监管，而区块链技术就是从其中分离出来的技术实现。所以区块链技术也就是去中心化（弱中心化）在去中心（弱中心化）的同时且能保证数据和系统的安全且遵循分布式系统的CAP理论。</p>
<h3 id="区块链7个特征"><a href="#区块链7个特征" class="headerlink" title="区块链7个特征"></a>区块链7个特征</h3><ol>
<li>区块链的存储基于分布式数据库；</li>
<li>数据库是区块链的数据载体，区块链是交易的业务逻辑载体；</li>
<li>区块链按时间序列化区块数据，整个网络有一个最终确定状态；</li>
<li>区块链只对添加有效，对其他操作无效；</li>
<li>交易基于非对称加密的公私钥验证；</li>
<li>区块链网络要求拜占庭将军容错;</li>
<li>共识算法能够“解决”双花问题。<h3 id="区块链的类型"><a href="#区块链的类型" class="headerlink" title="区块链的类型"></a>区块链的类型</h3><h4 id="1-共有链："><a href="#1-共有链：" class="headerlink" title="1. 共有链："></a>1. 共有链：</h4>我们先来介绍公有链。公有链 ，顾名思义，它是公有的、开放的。在区块链中，公有链是开放程度最高，也是去中心化属性最强的。</li>
</ol>
<p>在公有链中，数据的数据的存储、更新、维护、操作都不再依赖于一个中心化的服务器，而是依赖于每一个网络节点，这就意味着，公有链上的数据是由全球互联网上成千上万的网络节点共同记录维护的，没有人能够擅自篡改其中的数据。</p>
<h4 id="2-联盟链："><a href="#2-联盟链：" class="headerlink" title="2. 联盟链："></a>2. 联盟链：</h4><p>联盟链，是公司与公司、组织与组织之间达成联盟的模式，维护链上数据的节点都来自于该联盟中的公司或者组织，记录维护数据的权力掌握在联盟成员手中。采用联盟链的群体主要是：银行、保险、证券、商业协会、集团企业等。</p>
<p>联盟链其实很好理解，就是公司之间形成一种联盟的关系：</p>
<p>假设 A 公司、B 公司和 C 公司组成联盟链，那么，这条联盟链上的数据只对 A、B、C 三家公司的运维人员开放，维护联盟链的人只能是 A、B、C 三家公司的运维人员，只有他们才有操作数据的权利</p>
<h4 id="3-私有链"><a href="#3-私有链" class="headerlink" title="3. 私有链"></a>3. 私有链</h4><p>私有链是一种不对外公开的、只有被授权的节点才可以参与并查看数据的私有区块链。采用私有链的群体主要是大型金融机构、大型企业、政府部门等。</p>
<p>私有链最典型的就是央行开发的、用于发行央行数字货币的区块链，这个链只能由央行来做记账，个人是不可能参与记账的。</p>
<h3 id="区块链的核心技术组成"><a href="#区块链的核心技术组成" class="headerlink" title="区块链的核心技术组成"></a>区块链的核心技术组成</h3><h4 id="1-P2P-网络协议"><a href="#1-P2P-网络协议" class="headerlink" title="1. P2P 网络协议"></a>1. P2P 网络协议</h4><p>P2P 网络协议是所有区块链的最底层模块，负责交易数据的网络传输和广播、节点发现和维护。</p>
<h4 id="2-分布式一致性算法（共识机制）"><a href="#2-分布式一致性算法（共识机制）" class="headerlink" title="2. 分布式一致性算法（共识机制）"></a>2. 分布式一致性算法（共识机制）</h4><p>在经典分布式计算领域，我们有 Raft 和 Paxos 算法家族代表的非拜占庭容错算法，以及具有拜占庭容错特性的 PBFT 共识算法。</p>
<ul>
<li>PoW：通常是指在给定的约束下，求解一个特定难度的数学问题，谁解的速度快，谁就能获得记账权（出块）权利。这个求解过程往往会转换成计算问题，所以在比拼速度的情况下，也就变成了谁的计算方法更优，以及谁的设备性能更好。比特币本身的演化很好地诠释了这个问题，中本聪设计的思路本来是由 CPU 计算。随着市场发展，人们发现 GPU 也可以参与其中，而且效率可以达到十倍百倍，现在，这项工作基本以 ASIC 专业挖矿芯片为主。正如我们在挖矿的时候，买一台蚂蚁矿机53T，72T什么的，就是算力越高，收入就越高（也不一定）。</li>
<li>PoS：这是一种股权证明机制，它的基本概念是产生区块的难度应该与你在网络里所占的股权（所有权占比）成比例，目前有三个版本 PoS1.0、PoS2.0、PoS3.0。它实现的核心思路是：使用你所锁定代币的币龄（CoinAge）以及一个小的工作量证明，去计算一个目标值，当满足目标值时，你将可能获取记账权。</li>
<li>PoS：这是一种股权证明机制，它的基本概念是产生区块的难度应该与你在网络里所占的股权（所有权占比）成比例，目前有三个版本 PoS1.0、PoS2.0、PoS3.0。它实现的核心思路是：使用你所锁定代币的币龄（CoinAge）以及一个小的工作量证明，去计算一个目标值，当满足目标值时，你将可能获取记账权。<h4 id="3-加密签名算法"><a href="#3-加密签名算法" class="headerlink" title="3. 加密签名算法"></a>3. 加密签名算法</h4>我们常见的算法，也就是hash算法中的SHA256，比特币采用的算法，在挖矿的时候也就是采用的是这个算法。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>大概认识完区块链后，区块链技术就是一个以去中心化（弱中心化）为目的，由多个用户来进行维护，对数据进行分布式存储记录。这些数据并且是不可篡改的。<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3>根据区块链的技术我们思考一下哪里能用到呢，如何落地一个区块链项目呢（除过类似于比特币）？ 就像腾讯云提供的TBAAS区块链的基础服务，那我们如何使用TBAAS 来应用到业务逻辑上呢？？</li>
</ul>
<p>参考：1. <a href="https://time.geekbang.org/column/article/5601《深入浅出区块链陈浩元界CTO》" target="_blank" rel="noopener">https://time.geekbang.org/column/article/5601《深入浅出区块链陈浩元界CTO》</a><br>2. <a href="https://www.chainnews.com/articles/007931884124.htm《联闻》" target="_blank" rel="noopener">https://www.chainnews.com/articles/007931884124.htm《联闻》</a><br>3. wiki百科：<a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BEhe" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BEhe</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/%E4%BB%A5%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E7%90%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/" data-id="ckaam337z00000lcydz2d604g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-个人简历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/" class="article-date">
  <time datetime="2020-05-16T18:08:09.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/">个人简历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        

	<div class="row">
    <embed src="./袁新栋V2.pdf" width="100%" height="550" type="application/pdf">
	</div>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/" data-id="cka9y9ry60000vc7vccmv4prt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-比特币白皮书" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/" class="article-date">
  <time datetime="2020-05-16T17:58:07.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/">比特币白皮书</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        

	<div class="row">
    <embed src="https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf" width="100%" height="550" type="application/pdf">
	</div>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/" data-id="cka9xswi40000on7v5s3mf3lc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-比特币和区块链技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/" class="article-date">
  <time datetime="2020-05-16T17:28:38.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/">比特币和区块链技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h4><ol>
<li>比特币的创建者中本聪不满当时西方的货币政策。在他看来 , 西方国家中央银行对商业银行的保护以及其货币的过度增发是导致当时的金融危机的主要原因。<h4 id="exaple："><a href="#exaple：" class="headerlink" title="exaple："></a>exaple：</h4></li>
<li>开始人们用物品换物品，但是由于在交换的过程中，出现了携带不方便，难以换算等问题? </li>
<li>为解决这个问题人们还是想到了说是使用金子，容易保存且比较稀有，相对于以前方便携带，于是人们开始了实物货币时代。但是又遇到问题了，金子资源不够了，也会有磨损。</li>
<li>又有人提出了使用纸币，将所有金子都上缴等价换纸币，纸币只能由固定的地方（政府银行）印出来才有效，拥有固定的标号和签字等。当有损坏的时候可以拿着纸币去银行换取新的那么旧的纸币就销毁掉。</li>
<li>虽然在使用纸币的时候没有怎么遇到非常致命的问题，但是造币太累了，还有就是有人制造假币等等问题 于是又有人提出，我们为什么不去搞一个账本，所有的交易记录都放在账本上，把每个人目前所拥有的纸币都交上来，然后在数据库里面维护账户的信息。但是这个玩意还是有问题，就是如果这个数据库管理员有私心把这个账簿改掉了，那怎么办。</li>
<li>于是有一个天才科学家“中本聪”来了，他说：我们不要具体记录某个人算好的账，如剩余多少钱，而是去记录所有的交易，那么每个人有多少钱就可以通过交易记录推算出来。并且这个交易记录账本交给大家来维护。于是来了这个去中心化的记账系统，也叫做A Peer-to-Peer Electronic Cash System（一个点对点电子现金系统）。 <h4 id="什么是blockchain，什么是Bitcoins？两着又有什么关系呢？"><a href="#什么是blockchain，什么是Bitcoins？两着又有什么关系呢？" class="headerlink" title="什么是blockchain，什么是Bitcoins？两着又有什么关系呢？"></a>什么是blockchain，什么是Bitcoins？两着又有什么关系呢？</h4>   类比一下吧，支付宝中的金额数就是BTC，其保证金额正常转账正常交易的系统就是区块链，我现在就是类比一下，但是支付宝和这玩意完全是两会事！！！！再强调一下，我的意思是blochain是技术，bitCoins是一个服务。使用blockchain实现了bitCoins！！！ 但是我个人觉得这玩意更像是一个有一定算法的数据结构。咋先入门不BB那么深了！！</li>
</ol>
<h4 id="技术是用来干什么的，就是用来解决问题的吗！（也可以这么说吧，技术就是因为问题而产生的）那bitcoins都遇到了那些问题？而发明除了区块链这门技术？"><a href="#技术是用来干什么的，就是用来解决问题的吗！（也可以这么说吧，技术就是因为问题而产生的）那bitcoins都遇到了那些问题？而发明除了区块链这门技术？" class="headerlink" title="技术是用来干什么的，就是用来解决问题的吗！（也可以这么说吧，技术就是因为问题而产生的）那bitcoins都遇到了那些问题？而发明除了区块链这门技术？"></a>技术是用来干什么的，就是用来解决问题的吗！（也可以这么说吧，技术就是因为问题而产生的）那bitcoins都遇到了那些问题？而发明除了区块链这门技术？</h4><ol>
<li>为什么要发明bitcoins系统呢？正如我上面的example，诚信吗，被一个人控制。这玩意容易被修改掉, 如果说让所有的人都去维护账簿那岂不是妙哉！还有就是 bitcoins 系统是一个 transaction-based ledger 也就是说它是基于账单记录的一个交易账簿。 所以说所有人都必须知道这个账簿的所有交易记录才能去做帐，才能计算出来自己的btc余额，那么这就来问题了！那既然账簿都公布出去了，那这玩意岂不是完犊子了，张三说我出去“玩”的花费岂不是被老婆知道了！！这不就GG了，聪哥说这简单啊！说他也想到了！他也有老婆啊！这就牵扯到了密码学中的Asymmetric encryption（非对称加密）和 hash 算法 。使用BTC系统的人在创建账户的时候会有两个key ，public key（公匙） 和 private key（私匙）public key也就是类似与我们的账号，private key 也就是类似于我们的密码。 这样的话那这谁也不知道这个是谁啊 ，还有人就会问那他老婆钥匙知道他的public key 那也不就知道他是谁了！！！！  hash的算法可不是吃素的，这个public key 和 private key 是通过hash 算法计算出来的 其中bitcoins 系统中使用的算法就是sha256 ， 比如你是jingyangchun 通过hash算法后直接变成256个由0和1组合打二进制代码。但是有人就说他老婆反算回来不就行了！！ 好吧 这个算法是反算不回来的。现在被老婆发现这个问题解决了，那会不会有创建的private key 和 public key 和其他人是一样的呢？  这个算法的好处就是 colloction free  意思就是没有人能制造出hash 碰撞，hash碰撞的意思是 就是jingyangchun 在通过hash 计算后在人为的情况下是制造不出来相同的hash值的。所以说你是唯一的（这个的前提条件是：你的输入空间是足够大的，意思就是你这个jingyangchun简简单单的字符串是不行的，得再加 个字符串才可以的jingyangchun+weqhsvsdkhvsdkhdvhksvhk ）所以说账户的安全问题得到保证了！看下图！</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020012318201875.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/" data-id="cka9wnu4j0001d67v3l39cztp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-05-16T17:27:03.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">HTTP基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h1><p>web浏览器，服务器和相关的web的应用程序都是通过HTTP进行通信交互的，http是现代全球因特网中使用的公共语言。<br>http 使用的是 可靠地数据传输协议，因此即时数据来自地球的另一端，他也能够确保数据在传输的过程中不会被损坏。</p>
<h2 id="1-HTTP中的名词"><a href="#1-HTTP中的名词" class="headerlink" title="1. HTTP中的名词"></a>1. HTTP中的名词</h2><h3 id="1-Web客户端和服务器"><a href="#1-Web客户端和服务器" class="headerlink" title="1. Web客户端和服务器"></a>1. Web客户端和服务器</h3><p>我们平常使用的就是浏览器就是web客户端，问客户端的信息来源那就是服务器，平时所说的应用程序就是在服务器上部署，好比微博，微博上的照片等资源就是从服务器来的。<br><img src="https://img-blog.csdnimg.cn/20200412153804619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-媒体类型"><a href="#2-媒体类型" class="headerlink" title="2. 媒体类型"></a>2. 媒体类型</h3><p>客户端通过http请求服务端，会请求不同的资源，如视频，音频等等文件，所以http都为需要在web传书的资源都打上了类型，使用MIME的数据格式标签，打标记。这个标记一般都会存储在我们的首部（后面会讲到）</p>
<h3 id="3-资源"><a href="#3-资源" class="headerlink" title="3. 资源"></a>3. 资源</h3><p>web服务器是web资源的宿主，http是Web服务器和web客户端中间的媒介，资源的类型有很多种，包括我们所部属的应用程序列如jar包，或者是。class文件等等</p>
<h3 id="3-URI"><a href="#3-URI" class="headerlink" title="3. URI"></a>3. URI</h3><p>每一个web服务器都有一个名字，这样客户端就知道他要的资源是什么，即URL uniform Resource Identifier 统一资源标识符。列如 <a href="https://blog.csdn.net/weixin_40413961/article/details/105398407" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40413961/article/details/105398407</a> 这个地址就是我博客的URI ，URI是怎样只是HTTP协议去访问我的博客资源的，给定了URI，就可以HTTP就可以解析出对象。URI 有两种形式分别为URL 和 URN </p>
<h3 id="4-URL"><a href="#4-URL" class="headerlink" title="4. URL"></a>4. URL</h3><ol>
<li>URL是统一资源的定位符，是资源标识符最常见的形式，URL描述了一台特定的服务器上的特定资源。他可以明确地从固定的位获取资源。</li>
<li>URL的组成：  </li>
</ol>
<ul>
<li>url的第一部分是HTTP 说明访问资源所使用的协议</li>
<li>blog.csdn.net给出服务器的因特网地址</li>
<li>其余的部分就制定了web服务器上的资源路径<br>现在几乎所有的URI搜使用的是URL <h3 id="5-URN"><a href="#5-URN" class="headerlink" title="5. URN"></a>5. URN</h3></li>
</ul>
<p>1.URN是代表的是某个资源，也就他叫做统一资源名 就举个例子：苹果在哪里都是苹果，只要你用苹果这个统一资源名就会获取到苹果（假如世界上的苹果都一样的前提下）无论你的苹果放在哪里，且可以通过任何的途径拿到。</p>
<h3 id="6-事务"><a href="#6-事务" class="headerlink" title="6. 事务"></a>6. 事务</h3><ol>
<li>http 的事务有一条请求命令（游客户端发往服务器）和响应结果组成（服务器发往客户端的）。这种通信是通过名为HTTP报文的的格式化数据块进行的 <h3 id="7-方法"><a href="#7-方法" class="headerlink" title="7. 方法"></a>7. 方法</h3></li>
<li>HTTP支持几种不同的HTTP请求命令，这些命令被称为HTTP方法，每一条HTTP报文都包含一个HTTP方法。这些方法会告诉HTTP服务器需要执行什么动作（但是服务器内的应用程序到底是如何执行的我们并不知道，列如我们请求的是get 但是，我们在代码里面处理的时候是删除） ，</li>
<li>7种HTTP方法： </li>
</ol>
<ul>
<li>GET: GET通常用于请求服务器资源，HTTP/1.1是要求服务器实现此方法<br>  GET和HEAD是HTTP方法中的安全方法，因为他两被赋予的意义是获取资源而不是去更改资源，所以说的安全的。注意：但是这里的安全仅仅是所有的开发遵循规则的情况下。就如我肯上面所提到的请求的是GET但是服务器的应用程序执行了删除操作。那这肯定就不安全了。</li>
<li>HEAD: HEAD 的请求方式和GET 的行为很类似，但是服务器在响应中只返回首部。不会返回实体的主体部分。他和GET的区别就是一个会返回实体一个不会返回实体</li>
<li>POST：POST语法的定义是向服务器输入数据的，实际上，通常会用他来支持HTML的表单，表单一半填好数据会发送给服务器，服务器会将他发送到他要去的地方，可以是网关等地方，然后由应用程序去处理</li>
<li>DELETE： 顾名思义那就是URL请求的资源进行删除，客户端的应用程序无法保证程序一定执行，因为HTTP规范语序服务在不通知客户端的情况下撤销删除。</li>
<li>OPTIONS： 此方法在我们的平时编程种感觉是很少使用的，此方法的语法意思是请求WEB服务器告知其支持的各种功能。可以询问服务器都支持哪些方法。 </li>
<li>PUT： put语法的定义就是根据HTTP报文中的主体部分来创建一个由所请求的UR命名的新文档，或者这个URL已经存在就用这个主题来替代它。因为PUT会修改资源，所以很多WEB服务器都要求执行PUT之前，用密码登录。</li>
<li>TRACE： 当客户端发起一个请求的时候，这个请求有可能穿越防火墙，网关 ，代理等一些应用服务（列如一些回调服务）等，每一个中间节点都会对 hTTP报文进行修改。TRACE方法允许客户端在最终请求发送给服务器时，看看它变成了什么样子。TRACE请求会在目的服务器短发一个环回的诊断，行程最后的一站的服务器会返回一条 TRACE响应，并在响应的主体中返回接收到的请求报文。 <h3 id="8-状态码"><a href="#8-状态码" class="headerlink" title="8. 状态码"></a>8. 状态码</h3></li>
</ul>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100 -199</td>
<td>信息状态码</td>
</tr>
<tr>
<td>200-299</td>
<td>成功状态码</td>
</tr>
<tr>
<td>300-399</td>
<td>重定向资源码</td>
</tr>
<tr>
<td>400-499</td>
<td>客户端错误状态码</td>
</tr>
<tr>
<td>500-599</td>
<td>服务端错误状态吗</td>
</tr>
<tr>
<td>### 9. 报文</td>
<td></td>
</tr>
<tr>
<td>1. 报文可以分为： 请求报文和响应报文</td>
<td></td>
</tr>
<tr>
<td>1. 报文的组成是：起始行， 首部，主体。</td>
<td></td>
</tr>
<tr>
<td>2. 请求报文和响应报文的区别是？</td>
<td></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200412153841968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></td>
<td></td>
</tr>
<tr>
<td>3. 起始行可以分为两种：请求行和响应行两者的区别和组成如上图，不做赘述、请求行的其他组成：</td>
<td></td>
</tr>
<tr>
<td>- 方法</td>
<td></td>
</tr>
<tr>
<td>- 状态码</td>
<td></td>
</tr>
<tr>
<td>- 原因短语</td>
<td></td>
</tr>
<tr>
<td>- HTTP版本号</td>
<td></td>
</tr>
<tr>
<td>4. 首部：</td>
<td></td>
</tr>
<tr>
<td>- 通用首部</td>
<td></td>
</tr>
<tr>
<td>- 请求首部</td>
<td></td>
</tr>
<tr>
<td>- 响应首部</td>
<td></td>
</tr>
<tr>
<td>- 实体首部 说明实体的内部</td>
<td></td>
</tr>
<tr>
<td>- 扩展首部</td>
<td></td>
</tr>
<tr>
<td>### 10. 连接</td>
<td></td>
</tr>
<tr>
<td>1. HTTP权威指南：“世界上几乎所有的HTTP通信都是通过TCP/IP承载的，TCP/IP是全球计算机及网络设备都是在使用的一种常用的分组交换网络协议集”那就是HTTP的连接是由TCP来进行的。</td>
<td></td>
</tr>
<tr>
<td>2. TCP提供可靠的数据管道，http连接实际上就是TCP连接及使用规则，TCP为HTTP提供可靠地比特传输管道，从TCP连接一段填入数据会从另一端有序的，正确得传送出来。</td>
<td></td>
</tr>
<tr>
<td>3. TCP流是分段的，是由IP分组传送的 。HTTP 要传输一条报文的时候，会以流的形式通过一条打开的TCP管道有序传输。TCP收到数据流，将流砍成被称作段的小数据块，并将段封装在IP分组里，通过因特网进行传输。这些操作都是通过TCP/IP软件来处理的。每一个TCP分段都是有IP分组来承担，从一个ip地址发送到另一个IP地址。我们可以类比一下快递公司，两个城市的派发中心就是TCP 其中运输的车就是IP 快递（一批快递）就是HTTP报文 两个城市的派发中心建立连接后，将其快递封装在一辆辆的车里然后通过两个快递派发中心制定的路线管道有序正确的运输到目的地</td>
<td></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200412153910899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></td>
<td></td>
</tr>
<tr>
<td>4. TCP保持连接持续不断的运行，在计算机中在任意时刻都会有几条TCP连接处于打开状态。TCP是通过端口号 来保持所有的这些连接不断地运行</td>
<td></td>
</tr>
<tr>
<td>5. 使用TCP的套接字去编程，我们在写Java的时候操作协同会给我们提供操作TCP的API。这就是SOCKET套接字API这个API 移隐藏了TCP 和IP的所有细节。具体过程</td>
<td></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200412153932200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></td>
<td></td>
</tr>
<tr>
<td>### 11. TCP 性能考虑</td>
<td></td>
</tr>
<tr>
<td>1. HTTP紧挨着TCP，位于其上层，所以HTTP事务的性能在很大程度取决于底层TCP的性能</td>
<td></td>
</tr>
<tr>
<td>HTTP事务请求的过程中出现网络延时</td>
<td></td>
</tr>
</tbody></table>
<p>1）客户端解析URI，找到对应的IP地址和端口号。如果本地缓存有就会节约很多的时间，如果本地没有就会就进去DNS获取这个时间回达到数10秒</p>
<p> 2）客户端会发起TCP连接请求，并等待服务器返回一个接收链接的应答。这个请求回达到1到2S</p>
<p>3） 一旦连接建立起来吗，客户端就会通过新建立的TCP管道来发送HTTP请求数据到达后就会对其中的请求报文进行处理。在进行处理也是会耗时的，主要是是取决于HTTP服务器的应用程序的性能。</p>
<p>4）web服务器响应 回送HTTP响应。也是耗时的 </p>
<p>TCP网络延时的大小取决于硬件速度，网络和服务器的负载，请求和响应报文的尺寸，以及客户端介服务短的距离。<br>2. TCP的性能聚焦</p>
<ul>
<li>TCP连接建立握手： 在TCP建立连接的时候 会进行一些数据的确认和沟通，而达到确认建立连接（三次握手）。如果这次连接传入少量的得数据的话，这个建立连接的过程会严重降低HTTP的性能。<br>TCP三次握手和四次挥手：<a href="https://blog.csdn.net/weixin_40413961/article/details/105397536" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40413961/article/details/105397536</a></li>
<li>延时确认： 由于因特网自己无法保证数据的可靠传输所以TCP担任其这一重任，在每次传输完IP分组到目标地址的时候都会向发送端返回一个确认报文，由于报文很小，所以TCP允许在发往允许在发往相同方向的输出数据进行捎带。所以就有了延迟算法。将这个确认报文存放在本地的缓存里面，如果有回去的数据就将缓存里里面的报文稍待返回，100——200MS内没有的话，就单独返回确认报文</li>
<li>TCP慢启动拥塞控制 ：TCP 数据的传输的性能还取决于TCp连接的使用期.tcp连接会随着时间进行自我调谐，起处会限制连接的最大速度，如果数据传输成功了，会随着时间得推移，提高传输速度 。这种调节被称为TCP的慢启动用于因特网的突然过载和拥塞</li>
<li>数据聚集Nagle算法 ： TCP 有一个数据流入口应用程序可以将任意的尺寸的大小的数据放入TCP栈中，既是一次放入一个字节也是可以的。但是每每一个每个TCP段中都至少装载了40个字节的标记和首部。所以TCP发送大量包含少量数据的分组，网络的性能就会严重下降。nagle算法就是在发送一个分组之前，将大量的TCP 数据绑定在一起以提高网络的效率。NElage算法会因为小的HTTP报文无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。因为需要将小的数据聚合起来一块的发送所以就是阻止HTTP报文的发送。这也就会影像http的传输</li>
<li>TIME—_WAIT时延和端口耗尽: 在TCP端点关闭TCP链接的时候，会在内存中维护一个小的控制块，用来记录最近关闭的IP地址和端口号，这类信息只会维护一短时间（2MSL 为两分钟），以确保在这段时间内不会重复的去创建相同的地址和端口号。由于现在高速路由一般会把2MSL调到特别小，就会 出现一些性能问题具体的说法可看点击-&gt;。（<a href="https://blog.csdn.net/u010585120/article/details/80826999）" target="_blank" rel="noopener">https://blog.csdn.net/u010585120/article/details/80826999）</a><br>参考 ：HTTP权威指南</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="cka9wnu4m0004d67vc30h66yl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ThreadPoolExcutor源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-05-16T17:25:12.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ThreadPoolExcutor源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ThreadPoolExecutor的状态和属性"><a href="#ThreadPoolExecutor的状态和属性" class="headerlink" title="ThreadPoolExecutor的状态和属性"></a>ThreadPoolExecutor的状态和属性</h3><p>ThreadPoolExecutor线程池有5个状态，分别是：</p>
<ul>
<li>RUNNING：可以接受新的任务，也可以处理阻塞队列里的任务</li>
<li>SHUTDOWN：不接受新的任务，但是可以处理阻塞队列里的任务</li>
<li>STOP：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务</li>
<li>TIDYING：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个时候线程池的状态将会TIDYING，并且将要调用terminated方法</li>
<li>TERMINATED：终止状态。terminated方法调用完成以后的状态</li>
</ul>
<p>状态之间可以进行转换：</p>
<p>RUNNING -&gt; SHUTDOWN：手动调用shutdown方法，或者ThreadPoolExecutor要被GC回收的时候调用finalize方法，finalize方法内部也会调用shutdown方法</p>
<p>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow方法</p>
<p>SHUTDOWN -&gt; TIDYING：当队列和线程池都为空的时候</p>
<p>STOP -&gt; TIDYING：当线程池为空的时候</p>
<p>TIDYING -&gt; TERMINATED：terminated方法调用完成之后</p>
<p>ThreadPoolExecutor内部还保存着线程池的有效线程个数。</p>
<p>状态和线程数在ThreadPoolExecutor内部使用一个整型变量保存，没错，一个变量表示两种含义</p>
<p>为什么一个整型变量既可以保存状态，又可以保存数量？ 分析一下：</p>
<ol>
<li>首先，我们知道java中1个整型占4个字节，也就是32位，所以1个整型有32位。<br>所以整型1用二进制表示就是：00000000000000000000000000000001</li>
<li>整型-1用二进制表示就是：11111111111111111111111111111111(这个是补码，不懂的同学可以看下原码，反码，补码的知识)</li>
<li>在ThreadPoolExecutor，整型中32位的前3位用来表示线程池状态，后3位表示线程池中有效的线程数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 前3位表示状态，所有线程数占29位</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br></pre></td></tr></table></figure>
<p>线程池容量大小为 1 &lt;&lt; 29 - 1 = 00011111111111111111111111111111(二进制)，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br></pre></td></tr></table></figure>
<p>RUNNING状态 -1 &lt;&lt; 29 = 11111111111111111111111111111111 &lt;&lt; 29 =<br>11100000000000000000000000000000(前3位为111)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>


<p>SHUTDOWN状态 0 &lt;&lt; 29 = 00000000000000000000000000000000 &lt;&lt; 29 = 00000000000000000000000000000000(前3位为000)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>STOP状态 1 &lt;&lt; 29 = 00000000000000000000000000000001 &lt;&lt; 29 = 00100000000000000000000000000000(前3位为001)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>TIDYING状态 2 &lt;&lt; 29 = 00000000000000000000000000000010 &lt;&lt; 29 = 01000000000000000000000000000000(前3位为010)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>TERMINATED状态 3 &lt;&lt; 29 = 00000000000000000000000000000011 &lt;&lt; 29 = 01100000000000000000000000000000(前3位为011)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>清楚状态位之后，下面是获得状态和线程数的内部方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 得到线程数，也就是后29位的数字。 直接跟CAPACITY做一个与操作即可，CAPACITY就是的值就 1 &lt;&lt; 29 - 1 &#x3D; 00011111111111111111111111111111。 与操作的话前面3位肯定为0，相当于直接取后29位的值</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 得到状态，CAPACITY的非操作得到的二进制位11100000000000000000000000000000，然后做在一个与操作，相当于直接取前3位的的值</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或操作。相当于更新数量和状态两个操作</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<p>线程池初始化状态线程数变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化状态和数量，状态为RUNNING，线程数为0</span><br><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor执行任务"><a href="#ThreadPoolExecutor执行任务" class="headerlink" title="ThreadPoolExecutor执行任务"></a>ThreadPoolExecutor执行任务</h3><p>使用ThreadPoolExecutor执行任务的时候，可以使用execute或submit方法，submit方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显地看到，submit方法内部使用了execute方法，而且submit方法是有返回值的。在调用execute方法之前，使用FutureTask包装一个Runnable，这个FutureTask就是返回值。</p>
<p>由于submit方法内部调用execute方法，所以execute方法就是执行任务的方法，来看一下execute方法，execute方法内部分3个步骤进行处理。</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步。丢到阻塞队列之后，还需要再做一次验证(丢到阻塞队列之后可能另外一个线程关闭了线程池或者刚刚加入到队列的线程死了)。如果这个时候线程池不在RUNNING状态，把刚刚丢入队列的任务remove掉，调用reject方法，否则查看Worker数量，如果Worker数量为0，起一个新的Worker去阻塞队列里拿任务执行</li>
<li>丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法<br>上面说的Worker可以暂时理解为一个执行任务的线程。</li>
</ol>
<p>execute方法源码如下，上面提到的3个步骤对应源码中的3个注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;   &#x2F;&#x2F; 第一个步骤，满足线程池中的线程大小比基本大小要小</span><br><span class="line">        if (addWorker(command, true)) &#x2F;&#x2F; addWorker方法第二个参数true表示使用基本大小</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; &#x2F;&#x2F; 第二个步骤，线程池的线程大小比基本大小要大，并且线程池还在RUNNING状态，阻塞队列也没满的情况，加到阻塞队列里</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command)) &#x2F;&#x2F; 虽然满足了第二个步骤，但是这个时候可能突然线程池关闭了，所以再做一层判断</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!addWorker(command, false)) &#x2F;&#x2F; 第三个步骤，直接使用线程池最大大小。addWorker方法第二个参数false表示使用最大大小</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addWorker关系着如何起一个线程，再看addWorker方法之前，先看一下ThreadPoolExecutor的一个内部类Worker, Worker是一个AQS的实现类(为何设计成一个AQS在闲置Worker里会说明)，同时也是一个实现Runnable的类，使用独占锁，它的构造函数只接受一个Runnable参数，内部保存着这个Runnable属性，还有一个thread线程属性用于包装这个Runnable(这个thread属性使用ThreadFactory构造，在构造函数内完成thread线程的构造)，另外还有一个completedTasks计数器表示这个Worker完成的任务数。Worker类复写了run方法，使用ThreadPoolExecutor的runWorker方法(在addWorker方法里调用)，直接启动Worker的话，会调用ThreadPoolExecutor的runWork方法。==需要特别注意的是这个Worker是实现了Runnable接口的，thread线程属性使用ThreadFactory构造Thread的时候，构造的Thread中使用的Runnable其实就是Worker==。下面的Worker的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker    </span><br><span class="line">    extends AbstractQueuedSynchronizer</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This class will never be serialized, but we provide a</span><br><span class="line">     * serialVersionUID to suppress a javac warning.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6138294804551838833L;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;</span><br><span class="line">    final Thread thread;</span><br><span class="line">    &#x2F;** Initial task to run.  Possibly null. *&#x2F;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    &#x2F;** Per-thread task counter *&#x2F;</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="line">     * @param firstTask the first task (null if none)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用ThreadFactory构造Thread，这个构造的Thread内部的Runnable就是本身，也就是Worker。所以得到Worker的thread并start的时候，会执行Worker的run方法，也就是执行ThreadPoolExecutor的runWorker方法</span><br><span class="line">        setState(-1); 把状态位设置成-1，这样任何线程都不能得到Worker的锁，除非调用了unlock方法。这个unlock方法会在runWorker方法中一开始就调用，这是为了确保Worker构造出来之后，没有任何线程能够得到它的锁，除非调用了runWorker之后，其他线程才能获得Worker的锁</span><br><span class="line">        this.firstTask &#x3D; firstTask;</span><br><span class="line">        this.thread &#x3D; getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Delegates main run loop to outer runWorker  *&#x2F;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Lock methods</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; The value 0 represents the unlocked state.</span><br><span class="line">    &#x2F;&#x2F; The value 1 represents the locked state.</span><br><span class="line"></span><br><span class="line">    protected boolean isHeldExclusively() &#123;</span><br><span class="line">        return getState() !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">        if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryRelease(int unused) &#123;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        setState(0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">    public void unlock()      &#123; release(1); &#125;</span><br><span class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    void interruptIfStarted() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下addWorker源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 两个参数，firstTask表示需要跑的任务。boolean类型的core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span><br><span class="line">&#x2F;&#x2F; 返回值是boolean类型，true表示新任务被接收了，并且执行了。否则是false</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c); &#x2F;&#x2F; 线程池当前状态</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这个判断转换成 rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs !&#x3D; SHUTDOWN || firstTask !&#x3D; null || workQueue.isEmpty)。 </span><br><span class="line">        &#x2F;&#x2F; 概括为3个条件：</span><br><span class="line">        &#x2F;&#x2F; 1. 线程池不在RUNNING状态并且状态是STOP、TIDYING或TERMINATED中的任意一种状态</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 线程池不在RUNNING状态，线程池接受了新的任务 </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 线程池不在RUNNING状态，阻塞队列为空。  满足这3个条件中的任意一个的话，拒绝执行任务</span><br><span class="line"></span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c); &#x2F;&#x2F; 线程池线程个数</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize)) &#x2F;&#x2F; 如果线程池线程数量超过线程池最大容量或者线程数量超过了基本大小(core参数为true，core参数为false的话判断超过最大大小)</span><br><span class="line">                return false; &#x2F;&#x2F; 超过直接返回false</span><br><span class="line">            if (compareAndIncrementWorkerCount(c)) &#x2F;&#x2F; 没有超过各种大小的话，cas操作线程池线程数量+1，cas成功的话跳出循环</span><br><span class="line">                break retry;</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; 重新检查状态</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs) &#x2F;&#x2F; 如果状态改变了，重新循环操作</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 走到这一步说明cas操作成功了，线程池线程数量+1</span><br><span class="line">    boolean workerStarted &#x3D; false; &#x2F;&#x2F; 任务是否成功启动标识</span><br><span class="line">    boolean workerAdded &#x3D; false; &#x2F;&#x2F; 任务是否添加成功标识</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock; &#x2F;&#x2F; 得到线程池的可重入锁</span><br><span class="line">        w &#x3D; new Worker(firstTask); &#x2F;&#x2F; 基于任务firstTask构造worker</span><br><span class="line">        final Thread t &#x3D; w.thread; &#x2F;&#x2F; 使用Worker的属性thread，这个thread是使用ThreadFactory构造出来的</span><br><span class="line">        if (t !&#x3D; null) &#123; &#x2F;&#x2F; ThreadFactory构造出的Thread有可能是null，做个判断</span><br><span class="line">            mainLock.lock(); &#x2F;&#x2F; 锁住，防止并发</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 在锁住之后再重新检测一下状态</span><br><span class="line">                int c &#x3D; ctl.get();</span><br><span class="line">                int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123; &#x2F;&#x2F; 如果线程池在RUNNING状态或者线程池在SHUTDOWN状态并且任务是个null</span><br><span class="line">                    if (t.isAlive()) &#x2F;&#x2F; 判断线程是否还活着，也就是说线程已经启动并且还没死掉</span><br><span class="line">                        throw new IllegalThreadStateException(); &#x2F;&#x2F; 如果存在已经启动并且还没死的线程，抛出异常</span><br><span class="line">                    workers.add(w); &#x2F;&#x2F; worker添加到线程池的workers属性中，是个HashSet</span><br><span class="line">                    int s &#x3D; workers.size(); &#x2F;&#x2F; 得到目前线程池中的线程个数</span><br><span class="line">                    if (s &gt; largestPoolSize) &#x2F;&#x2F; 如果线程池中的线程个数超过了线程池中的最大线程数时，更新一下这个最大线程数</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    workerAdded &#x3D; true; &#x2F;&#x2F; 标识一下任务已经添加成功</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123; &#x2F;&#x2F; 如果任务添加成功，运行任务，改变一下任务成功启动标识</span><br><span class="line">                t.start(); &#x2F;&#x2F; 启动线程，这里的t是Worker中的thread属性，所以相当于就是调用了Worker的run方法</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted) &#x2F;&#x2F; 如果任务启动失败，调用addWorkerFailed方法</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Worker中的线程start的时候，调用Worker本身run方法，这个run方法之前分析过，调用外部类ThreadPoolExecutor的runWorker方法，直接看runWorker方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt &#x3D; Thread.currentThread(); &#x2F;&#x2F; 得到当前线程</span><br><span class="line">    Runnable task &#x3D; w.firstTask; &#x2F;&#x2F; 得到Worker中的任务task，也就是用户传入的task</span><br><span class="line">    w.firstTask &#x3D; null; &#x2F;&#x2F; 将Worker中的任务置空</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts。 </span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果worker中的任务不为空，继续知否，否则使用getTask获得任务。一直死循环，除非得到的任务为空才退出</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();  &#x2F;&#x2F; 如果拿到了任务，给自己上锁，表示当前Worker已经要开始执行任务了，已经不是闲置Worker(闲置Worker的解释请看下面的线程池关闭)</span><br><span class="line">            &#x2F;&#x2F; 在执行任务之前先做一些处理。 1. 如果线程池已经处于STOP状态并且当前线程没有被中断，中断线程 2. 如果线程池还处于RUNNING或SHUTDOWN状态，并且当前线程已经被中断了，重新检查一下线程池状态，如果处于STOP状态并且没有被中断，那么中断线程</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task); &#x2F;&#x2F; 任务执行前需要做什么，ThreadPoolExecutor是个空实现</span><br><span class="line">                Throwable thrown &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run(); &#x2F;&#x2F; 真正的开始执行任务，调用的是run方法，而不是start方法。这里run的时候可能会被中断，比如线程池调用了shutdownNow方法</span><br><span class="line">                &#125; catch (RuntimeException x) &#123; &#x2F;&#x2F; 任务执行发生的异常全部抛出，不在runWorker中处理</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown); &#x2F;&#x2F; 任务执行结束需要做什么，ThreadPoolExecutor是个空实现</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task &#x3D; null;</span><br><span class="line">                w.completedTasks++; &#x2F;&#x2F; 记录执行任务的个数</span><br><span class="line">                w.unlock(); &#x2F;&#x2F; 执行完任务之后，解锁，Worker变成闲置Worker</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly); &#x2F;&#x2F; 回收Worker方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下getTask方法是如何获得任务的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果发生了以下四件事中的任意一件，那么Worker需要被回收：</span><br><span class="line">&#x2F;&#x2F; 1. Worker个数比线程池最大大小要大</span><br><span class="line">&#x2F;&#x2F; 2. 线程池处于STOP状态</span><br><span class="line">&#x2F;&#x2F; 3. 线程池处于SHUTDOWN状态并且阻塞队列为空</span><br><span class="line">&#x2F;&#x2F; 4. 使用超时时间从阻塞队列里拿数据，并且超时之后没有拿到数据(allowCoreThreadTimeOut || workerCount &gt; corePoolSize)</span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut &#x3D; false; &#x2F;&#x2F; 如果使用超时时间并且也没有拿到任务的标识</span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果线程池是SHUTDOWN状态并且阻塞队列为空的话，worker数量减一，直接返回null(SHUTDOWN状态还会处理阻塞队列任务，但是阻塞队列为空的话就结束了)，如果线程池是STOP状态的话，worker数量建议，直接返回null(STOP状态不处理阻塞队列任务)[方法一开始注释的2，3两点，返回null，开始Worker回收]</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean timed;      &#x2F;&#x2F; 标记从队列中取任务时是否设置超时时间，如果为true说明这个worker可能需要回收，为false的话这个worker会一直存在，并且阻塞当前线程等待阻塞队列中有数据</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c); &#x2F;&#x2F; 得到当前线程池Worker个数</span><br><span class="line">            &#x2F;&#x2F; allowCoreThreadTimeOut属性默认为false，表示线程池中的核心线程在闲置状态下还保留在池中；如果是true表示核心线程使用keepAliveTime这个参数来作为超时时间</span><br><span class="line">            &#x2F;&#x2F; 如果worker数量比基本大小要大的话，timed就为true，需要进行回收worker</span><br><span class="line">            timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize; </span><br><span class="line"></span><br><span class="line">            if (wc &lt;&#x3D; maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)) &#x2F;&#x2F; 方法一开始注释的1，4两点，会进行下一步worker数量减一</span><br><span class="line">                break;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c)) &#x2F;&#x2F; worker数量减一，返回null，之后会进行Worker回收工作</span><br><span class="line">                return null;</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; 重新检查线程池状态</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs) &#x2F;&#x2F; 线程池状态改变的话重新开始外部循环，否则继续内部循环</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果需要设置超时时间，使用poll方法，否则使用take方法一直阻塞等待阻塞队列新进数据</span><br><span class="line">            Runnable r &#x3D; timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r !&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut &#x3D; true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut &#x3D; false; &#x2F;&#x2F; 闲置Worker被中断</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果getTask返回的是null，那说明阻塞队列已经没有任务并且当前调用getTask的Worker需要被回收，那么会调用processWorkerExit方法进行回收：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    if (completedAbruptly) &#x2F;&#x2F; 如果Worker没有正常结束流程调用processWorkerExit方法，worker数量减一。如果是正常结束的话，在getTask方法里worker数量已经减一了</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 加锁，防止并发问题</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount +&#x3D; w.completedTasks; &#x2F;&#x2F; 记录总的完成任务数</span><br><span class="line">        workers.remove(w); &#x2F;&#x2F; 线程池的worker集合删除掉需要回收的Worker</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate(); &#x2F;&#x2F; 尝试结束线程池</span><br><span class="line"></span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;  &#x2F;&#x2F; 如果线程池还处于RUNNING或者SHUTDOWN状态</span><br><span class="line">        if (!completedAbruptly) &#123; &#x2F;&#x2F; Worker是正常结束流程的话</span><br><span class="line">            int min &#x3D; allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min &#x3D;&#x3D; 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min &#x3D; 1;</span><br><span class="line">            if (workerCountOf(c) &gt;&#x3D; min)</span><br><span class="line">                return; &#x2F;&#x2F; 不需要新开一个Worker</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 新开一个Worker代替原先的Worker</span><br><span class="line">        &#x2F;&#x2F; 新开一个Worker需要满足以下3个条件中的任意一个：</span><br><span class="line">        &#x2F;&#x2F; 1. 用户执行的任务发生了异常</span><br><span class="line">        &#x2F;&#x2F; 2. Worker数量比线程池基本大小要小</span><br><span class="line">        &#x2F;&#x2F; 3. 阻塞队列不空但是没有任何Worker在工作</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在回收Worker的时候线程池会尝试结束自己的运行，tryTerminate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 满足3个条件中的任意一个，不终止线程池</span><br><span class="line">        &#x2F;&#x2F; 1. 线程池还在运行，不能终止</span><br><span class="line">        &#x2F;&#x2F; 2. 线程池处于TIDYING或TERMINATED状态，说明已经在关闭了，不允许继续处理</span><br><span class="line">        &#x2F;&#x2F; 3. 线程池处于SHUTDOWN状态并且阻塞队列不为空，这时候还需要处理阻塞队列的任务，不能终止线程池</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F; 走到这一步说明线程池已经不在运行，阻塞队列已经没有任务，但是还要回收正在工作的Worker</span><br><span class="line">        if (workerCountOf(c) !&#x3D; 0) &#123;</span><br><span class="line">             &#x2F;&#x2F; 由于线程池不运行了，调用了线程池的关闭方法，在解释线程池的关闭原理的时候会说道这个方法</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE); &#x2F;&#x2F; 中断闲置Worker，直到回收全部的Worker。这里没有那么暴力，只中断一个，中断之后退出方法，中断了Worker之后，Worker会回收，然后还是会调用tryTerminate方法，如果还有闲置线程，那么继续中断</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 走到这里说明worker已经全部回收了，并且线程池已经不在运行，阻塞队列已经没有任务。可以准备结束线程池了</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock(); &#x2F;&#x2F; 加锁，防止并发</span><br><span class="line">        try &#123;</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; &#x2F;&#x2F; cas操作，将线程池状态改成TIDYING</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated(); &#x2F;&#x2F; 调用terminated方法</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0)); &#x2F;&#x2F; terminated方法调用完毕之后，状态变为TERMINATED</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释了这么多，对线程池的启动并且执行任务做一个总结：</p>
<p>首先，构造线程池的时候，需要一些参数。一些重要的参数解释在 java内置的线程池笔记 文章中的结尾已经说明了一下重要参数的意义。</p>
<p>线程池构造完毕之后，如果用户调用了execute或者submit方法的时候，最后都会使用execute方法执行。</p>
<p>execute方法内部分3种情况处理任务：</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步</li>
<li>丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法</li>
</ol>
<p>线程池中的这个基本大小指的是Worker的数量。一个Worker是一个Runnable的实现类，会被当做一个线程进行启动。Worker内部带有一个Runnable属性firstTask，这个firstTask可以为null，为null的话Worker会去阻塞队列拿任务执行，否则会先执行这个任务，执行完毕之后再去阻塞队列继续拿任务执行。</p>
<p>所以说如果Worker数量超过了基本大小，那么任务都会在阻塞队列里，当Worker执行完了它的第一个任务之后，就会去阻塞队列里拿其他任务继续执行。</p>
<p>Worker在执行的时候会根据一些参数进行调节，比如Worker数量超过了线程池基本大小或者超时时间到了等因素，这个时候Worker会被线程池回收，线程池会尽量保持内部的Worker数量不超过基本大小。</p>
<p>另外Worker执行任务的时候调用的是Runnable的run方法，而不是start方法，调用了start方法就相当于另外再起一个线程了。</p>
<p>Worker在回收的时候会尝试终止线程池。尝试关闭线程池的时候，会检查是否还有Worker在工作，检查线程池的状态，没问题的话会将状态过度到TIDYING状态，之后调用terminated方法，terminated方法调用完成之后将线程池状态更新到TERMINATED。</p>
<h3 id="ThreadPoolExecutor的关闭"><a href="#ThreadPoolExecutor的关闭" class="headerlink" title="ThreadPoolExecutor的关闭"></a>ThreadPoolExecutor的关闭</h3><p>线程池的启动过程分析好了之后，接下来看线程池的关闭操作：</p>
<p>shutdown方法，关闭线程池，关闭之后阻塞队列里的任务不受影响，会继续被Worker处理，但是新的任务不会被接受：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 关闭的时候需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess(); &#x2F;&#x2F; 检查关闭线程池的权限</span><br><span class="line">        advanceRunState(SHUTDOWN); &#x2F;&#x2F; 把线程池状态更新到SHUTDOWN</span><br><span class="line">        interruptIdleWorkers(); &#x2F;&#x2F; 中断闲置的Worker</span><br><span class="line">        onShutdown(); &#x2F;&#x2F; 钩子方法，默认不处理。ScheduledThreadPoolExecutor会做一些处理</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); &#x2F;&#x2F; 尝试结束线程池，上面已经分析过了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interruptIdleWorkers方法，注意，这个方法打断的是闲置Worker，打断闲置Worker之后，getTask方法会返回null，然后Worker会被回收。那什么是闲置Worker呢？</p>
<p>闲置Worker是这样解释的：Worker运行的时候会去阻塞队列拿数据(getTask方法)，拿的时候如果没有设置超时时间，那么会一直阻塞等待阻塞队列进数据，这样的Worker就被称为闲置Worker。由于Worker也是一个AQS，在runWorker方法里会有一对lock和unlock操作，这对lock操作是为了确保Worker不是一个闲置Worker。</p>
<p>所以Worker被设计成一个AQS是为了根据Worker的锁来判断是否是闲置线程，是否可以被强制中断。</p>
<p>下面我们看下interruptIdleWorkers方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用他的一个重载方法，传入了参数false，表示要中断所有的正在运行的闲置Worker，如果为true表示只打断一个闲置Worker</span><br><span class="line">private void interruptIdleWorkers() &#123;</span><br><span class="line">    interruptIdleWorkers(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 中断闲置Worker需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers) &#123; </span><br><span class="line">            Thread t &#x3D; w.thread; &#x2F;&#x2F; 拿到worker中的线程</span><br><span class="line">            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; &#x2F;&#x2F; Worker中的线程没有被打断并且Worker可以获取锁，这里Worker能获取锁说明Worker是个闲置Worker，在阻塞队列里拿数据一直被阻塞，没有数据进来。如果没有获取到Worker锁，说明Worker还在执行任务，不进行中断(shutdown方法不会中断正在执行的任务)</span><br><span class="line">                try &#123;</span><br><span class="line">                    t.interrupt();  &#x2F;&#x2F; 中断Worker线程</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    w.unlock(); &#x2F;&#x2F; 释放Worker锁</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (onlyOne) &#x2F;&#x2F; 如果只打断1个Worker的话，直接break退出，否则，遍历所有的Worker</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdown方法将线程池状态改成SHUTDOWN，线程池还能继续处理阻塞队列里的任务，并且会回收一些闲置的Worker。但是shutdownNow方法不一样，它会把线程池状态改成STOP状态，这样不会处理阻塞队列里的任务，也不会处理新的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; shutdownNow方法会有返回值的，返回的是一个任务列表，而shutdown方法没有返回值</span><br><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; shutdownNow操作也需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess(); &#x2F;&#x2F; 检查关闭线程池的权限</span><br><span class="line">        advanceRunState(STOP); &#x2F;&#x2F; 把线程池状态更新到STOP</span><br><span class="line">        interruptWorkers(); &#x2F;&#x2F; 中断Worker的运行</span><br><span class="line">        tasks &#x3D; drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); &#x2F;&#x2F; 尝试结束线程池，上面已经分析过了</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br><span class="line">shutdownNow的中断和shutdown方法不一样，调用的是interruptWorkers方法：</span><br><span class="line"></span><br><span class="line">private void interruptWorkers() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock(); &#x2F;&#x2F; 中断Worker需要加锁，防止并发</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted(); &#x2F;&#x2F; 中断Worker的执行</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock(); &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Worker的interruptIfStarted方法中断Worker的执行：</span><br><span class="line"></span><br><span class="line">void interruptIfStarted() &#123;</span><br><span class="line">   Thread t;</span><br><span class="line">   &#x2F;&#x2F; Worker无论是否被持有锁，只要还没被中断，那就中断Worker</span><br><span class="line">   if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           t.interrupt(); &#x2F;&#x2F; 强行中断Worker的执行</span><br><span class="line">       &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池关闭总结：</p>
<p>线程池的关闭主要是两个方法，shutdown和shutdownNow方法。</p>
<p>shutdown方法会更新状态到SHUTDOWN，不会影响阻塞队列里任务的执行，但是不会执行新进来的任务。同时也会回收闲置的Worker，闲置Worker的定义上面已经说过了。</p>
<p>shutdownNow方法会更新状态到STOP，会影响阻塞队列的任务执行，也不会执行新进来的任务。同时会回收所有的Worker。</p>
<p>上一个图： <img src="https://img-blog.csdnimg.cn/20200330233559797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>原文链接：<a href="https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" target="_blank" rel="noopener">https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="cka9wnu4k0002d67vc518ef06" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql中char和varchar" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/mysql%E4%B8%ADchar%E5%92%8Cvarchar/" class="article-date">
  <time datetime="2020-05-16T17:20:11.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/mysql%E4%B8%ADchar%E5%92%8Cvarchar/">mysql中char和varchar</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol>
<li>同事在设计表，有一个字段为发票号码，在一般来讲发票号码的长度一般是8位，varchar类型， 他的意思是给20位，我的意思是给少点12位就够了。又因为我们在老的业务里给的是12位，出现过存储的字段过长而导致未能存储的问题。但是解决这个问题的方法是在业务逻辑层做check 然后进行截取（目前我的做法）。因为本来超过了就是不对的，所以这样处理。为何要浪费那个空间呢？？于是又讨论到了varchar在MySQL中的存储方式。，以证明增加长度所占用的空间并不大。那么我们就看看varchar在mysql中到底是如何存储的。<br><img src="https://img-blog.csdnimg.cn/20200430020431489.png" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-groB6tX9-1588183138504)(888699C078F84130ABF13971FB8603BA)\]"></li>
</ol>
<h3 id="varchar类型在mysql中是如何定义的？"><a href="#varchar类型在mysql中是如何定义的？" class="headerlink" title="varchar类型在mysql中是如何定义的？"></a>varchar类型在mysql中是如何定义的？</h3><p>先看看官方文档:<br><img src="https://img-blog.csdnimg.cn/20200430015958598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DKTDwWGs-1588183138508)(B3537769584041E68E32AA7A3CCDAC89)\]
\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KtswjSHH-1588183138512)(27047CF8A8F1454B9DCD08E82A0BCBDD)\]"><br><img src="https://img-blog.csdnimg.cn/20200430020053198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>==上面是8.0和5.7的文档这个得小心点==</p>
<p>大概意思： </p>
<ol>
<li>char：存储定长数据很方便，CHAR字段上的索引效率级高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不论你存储的数据是否达到了10个字符，都要占去10个字符的空间（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。</li>
<li>varchar：存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。</li>
</ol>
<h3 id="ALL-IN-ALL"><a href="#ALL-IN-ALL" class="headerlink" title="ALL IN ALL"></a>ALL IN ALL</h3><p>在MySQL数据库中，用的最多的字符型数据类型就是Varchar和Char.。这两种数据类型虽然都是用来存放字符型数据，但是无论从结构还是从数据的保存方式来看，两者相差很大。而且其具体的实现方式，还依赖与存储引擎。我这里就以大家最常用的MYISAM存储引擎为例，谈谈这两种数据类型的差异。在后续建议中，也是针对这种存储类型而言的。</p>
<ol>
<li>这里首先需要明白的一点是，这两种数据类型，无论采用哪一种存储引起，系统存储数据的方式都是不同的。正是因为如此，我们才有必要研究两者的不同。然后在合适的情况下，采用恰当的方式。了解这一点之后，我们再来看后续的内容。</li>
<li>Varchar往往用来保存可变长度的字符串。简单的说，我们只是给其固定了一个最大值，然后系统会根据实际存储的数据量来分配合适的存储空间。为此相比CHAR字符数据而言，其能够比固定长度类型占用更少的存储空间。不过在实际工作中，由于某系特殊的原因，会在这里设置例外。==如管理员可以根据需要指定ROW_FORMAT=FIXED选项==（innodb的 文档地址：<a href="官方文档地址">https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html</a>）。利用这个选项来创建MyISAM表的话，系统将会为每一行使用固定长度的空间。此时会造成存储空间的损耗。通常情况下，VARCHAR数据类型能够节约磁盘空间，为此往往认为其能够提升数据库的性能。不过这里需要注意的是，这往往是一把双刃剑。其在提升性能的同时，往往也会产生一些副作用。如因为其长度是可变的，为此在数据进行更新时可能会导致一些额外的工作。如在更改前，其字符长度是10位(Varchar规定的最长字符数假设是50位)，此时系统就只给其分配10个存储的位置(假设不考虑系统自身的开销)。更改后，其数据量达到了20位。由于没有超过最大50位的限制，为此数据库还是允许其存储的。只是其原先的存储位置已经无法满足其存储的需求。此时系统就需要进行额外的操作。如根据存储引擎不同，有的会采用拆分机制，而有的则会采用分页机制。其实也好比我们在Java中使用容器类，为什么在使用的时候需要刚开始位给定一个容器的大小呢？也就是为了防止扩容对性能的消耗。</li>
<li>CHAR数据类型与VARCHAR数据类型不同，其采用的是固定长度的存储方式。简单的说，就是系统总为其分配最大的存储空间。当数据保存时，即使其没有达到最大的长度，系统也会为其分配这么多的存储空间。显然，这种存储方式会造成磁盘空间的浪费。这里笔者需要提醒的一点是，当字符位数不足时，系统并不会采用空格来填充。相反，如果在保存CHAR值的时候，如果其后面有空值，系统还会自动过滤其空格。而在进行数据比较时，系统又会将空格填充到字符串的末尾。</li>
<li>显然，VARCHAR与CHAR两种字符型数据类型相比，最大的差异就是前者是可变长度，而后者则是固定长度。在存储时，前者会根据实际存储的数据来分配最终的存储空间。而后者则不管实际存储数据的长度，都是根据CHAR规定的长度来分配存储空间。这是否意味着CHAR的数据类型劣于VARCHAR呢?其实不然。否则的话，就没有必要存在CHAR字符类型了。虽然VARCHAR数据类型可以节省存储空间，提高数据处理的效率。但是其可变长度带来的一些负面效应，有时候会抵消其带来的优势。为此在某些情况下，还是需要使用Char数据类型。</li>
</ol>
<h4 id="项目建议"><a href="#项目建议" class="headerlink" title="项目建议"></a>项目建议</h4><p>　　根据上面的分析，我们知道VARCHAR数据类型是一把双刃剑，其在带来性能提升的同时，也可能会存在着一些额外的消耗。我们在评估到底是使用VARCHAR数据类型还是采用CHAR数据类型时，就需要进行均衡。在实际项目中，我们会考量如下情况。</p>
<ol>
<li><p>==是根据字符的长度来判断==。如某个字段，像人的名字，其最长的长度也是有限的。如我们给其分配18个字符长度即可。此时虽然每个人的名字长度有可能不同，但是即使为其分配了固定长度的字符类型，即18个字符长度，最后浪费的空间也不是很大。而如果采用VARCHAR数据类型时，万一以后需要改名，而原先的存储空间不足用来容纳新的值，反而会造成一些额外的工作。在这种情况下，进行均衡时，会认为采用CHAR固定长度的数据类型更好。在实际项目中，如果某个字段的字符长度比较短此时一般是采用固定字符长度。</p>
</li>
<li><p>==是考虑其长度的是否相近==。如果某个字段其长度虽然比较长，但是其长度总是近似的，如一般在90个到100个字符之间，甚至是相同的长度。此时比较适合采用CHAR字符类型。比较典型的应用就是MD5哈希值。当利用MD5哈希值来存储用户密码时，就非常适合采用CHAR字符类型。因为其长度是相同的。另外，像用来存储用户的身份证号码等等，一般也建议使用CHAR类型的数据。<br>　　另外请大家考虑一个问题，CHAR(1)与VARCHAR(1)两这个定义，会有什么区别呢?虽然这两个都只能够用来保存单个的字符，但是VARCHAR要比CHAR多占用一个存储位置。这主要是因为使用VARCHAR数据类型时，会多用1个字节用来存储长度信息(根据开销的大小来判断的)。这个管理上的开销CHAR字符类型是没有的。</p>
</li>
<li><p>==从碎片角度进行考虑==。使用CHAR字符型时，由于存储空间都是一次性分配的。为此某个字段的内容，其都是存储在一起的。单从这个角度来讲，其不存在碎片的困扰。而可变长度的字符数据类型，其存储的长度是可变的。当其更改前后数据长度不一致时，就不可避免的会出现碎片的问题。故使用可变长度的字符型数据时，数据库管理员要时不时的对碎片进行整理。如执行数据库导出导入作业，来消除碎片。</p>
</li>
<li><p>==即使使用Varchar数据类型，也不能够太过于慷慨==。这是什么意思呢?如现在用户需要存储一个地址信息。根据评估，只要使用100个字符就可以了。但是有些数据库管理员会认为，反正Varchar数据类型是根据实际的需要来分配长度的。还不如给其大一点的呢。为此他们可能会为这个字段一次性分配200个字符的存储空间。这VARCHAR(100)与VARCHAR(200)真的相同吗?结果是否定的。虽然他们用来存储90个字符的数据，其存储空间相同。但是对于内存的消耗是不同的。对于VARCHAR数据类型来说，硬盘上的存储空间虽然都是根据实际字符长度来分配存储空间的，但是对于内存来说，则不是。==其时使用固定大小的内存块来保存值。简单的说，就是使用字符类型中定义的长度，即200个字符空间。显然，这对于排序或者临时表(这些内容都需要通过内存来实现)作业会产生比较大的不利影响==。所以如果某些字段会涉及到文件排序或者基于磁盘的临时表时，分配VARCHAR数据类型时仍然不能够太过于慷慨。还是要评估实际需要的长度，然后选择一个最长的字段来设置字符长度。如果为了考虑冗余，可以留10%左右的字符长度。千万不能认为其为根据实际长度来分配存储空间，而随意的分配长度，或者说干脆使用最大的字符长度。</p>
<h2 id="所以说：刚invoiceNo设置为char类型-切设置为12个字节大小。"><a href="#所以说：刚invoiceNo设置为char类型-切设置为12个字节大小。" class="headerlink" title="所以说：刚invoiceNo设置为char类型 切设置为12个字节大小。"></a>所以说：刚invoiceNo设置为char类型 切设置为12个字节大小。</h2><p>拓展：</p>
</li>
<li><p>还有就是我们在使用索引的时候，在插入和更新的时候使用的是指定的长度还是正式字符的长度？？？？我给自己留个问好？<br><img src="https://img-blog.csdnimg.cn/20200430020118369.png" alt="在这里插入图片描述"></p>
</li>
<li><p>竟然创建成功了。看了下是自动截取了255个字符。所以没能验证成功，本以为是因为innoDB 中索引的字段长度不能超过767个字节，如果是按照预先给的长度的话肯定会创建失败的。但是现在他是自动截取到了255，但是里面给的字段是不到255的，所以是可以证明是按照预先给的来决定的。<br><img src="https://img-blog.csdnimg.cn/2020043002013765.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>然后我有给了char（254）仍然是直接成功，查看了索引的字节数感觉有点对不上，明天再看看<br><img src="https://img-blog.csdnimg.cn/20200430020204832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/mysql%E4%B8%ADchar%E5%92%8Cvarchar/" data-id="cka9wnu4d0000d67veh8j8ozl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JVM线上内存问题排查" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/JVM%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" class="article-date">
  <time datetime="2020-05-16T17:16:23.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/JVM%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">JVM线上内存问题排查</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>正在和同事在外面吃饭，突然钉钉报警，有一个服务的机器内存飙到百分之90%多。和同事大概聊了一下说是队列累积，机器消费不过来，具体原因也没有深问，又一同事，说看一下是那个对象占的内存，使用jmap，jstat。当时我也在旁边围观，由于之前有看过，我就说jmap在生产环境敢使用吗？</p>
<h3 id="jmap，jstat的作用？"><a href="#jmap，jstat的作用？" class="headerlink" title="jmap，jstat的作用？"></a>jmap，jstat的作用？</h3><ol>
<li>jmap 是内存影像工具，jmap用于生成堆转储快照（一般称为dump或者heapdump文件）也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</li>
<li>使用参数 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>
，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件<br>使用参数 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnCtrlBreak</span><br></pre></td></tr></table></figure>
然后使用 Ctrl+Break 生成<br>在 Linux 系统中使用 kill -3 发送进程退出信号“吓唬”虚拟机，让其生成 dump 文件）</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200422190105915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OCb40veR-1587553128975)(46F37BAEACA9493FAF0FC1C9ED6886EF)\]"><br>2. jstat (JVM statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具他可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据，在没有GUI图形界面 ,只提供了纯文本控制台环境的服务器上，他是运行期定位虚拟机的首选工具（周志明说）<br><img src="https://img-blog.csdnimg.cn/20200422190139964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="jmap实战"><a href="#jmap实战" class="headerlink" title="jmap实战"></a>jmap实战</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lQojpBgg-1587553128990)(CF4BE02FA6C941DEB23E041B50C4FAE7)]</p>
<ol>
<li>首先我们使用jps命令查看当前运行在JVM上的应用的LVMID也就是我上图的28398</li>
<li>拿到这个后使用jmap -dump命令<br><img src="https://img-blog.csdnimg.cn/20200422190200219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format&#x3D;b,file&#x3D;dumpHeap.bin 28398</span><br></pre></td></tr></table></figure></li>
<li>执行成功后使用ll就可以看到dump 下来的文件</li>
<li>接下来我们可以使用其他的分析工具进行分析 如：jhat ，Visual VM，MAT等。周志明说：能用其他工具就不要用jhat原因是：一般不会在部署应用的服务器上进行分析dump文件，分析dump文件是一件非常耗费硬件资源的过程，第二个原因就是jhat很简陋。所以还是使用将多个功能放在一块的工具Visual VM来进行分析。</li>
</ol>
<p>Tips : 但是这个dump在生产环境中还是慎用，因为在dump文件的过程中为保证文件的准确性会停止所有的进程的（个人觉得有点类似于gc 中的stop the word）</p>
<h3 id="jstat-实战"><a href="#jstat-实战" class="headerlink" title="jstat 实战"></a>jstat 实战</h3><p><img src="https://img-blog.csdnimg.cn/20200422190253806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>jps获取服务的LVMID</li>
<li>jstat -gc </li>
<li>我们从图中可以观察到 其中 S0 和 S1 指 Survivor0 区和 Survivor1区，E 即 Eden 区，O 指老年代，M 指 MetaSpace，元数据空间，CCS 是压缩使用比例，YGC：年轻代垃圾回收次数，FGC：老年代垃圾回收次数，FGCT：老年代垃圾回收消耗时间，GCT：垃圾回收消耗总时间。当我们拿到了生产上的信息，且进行了分析，那我们就得查看现有的配置。那就是用jinfo <h3 id="jinfo实战"><a href="#jinfo实战" class="headerlink" title="jinfo实战"></a>jinfo实战</h3><img src="https://img-blog.csdnimg.cn/20200422190310978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-88RzgrlE-1587553128999)(194849B176BF4920A366E5317A6EE32A)\]"></li>
<li>不管怎样我们都得查找到LVMID</li>
<li>通过jinfo查看得到该应用程序的现有配置。</li>
<li>或者说我们使用的jekins自动化构建工具那我们可以在</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;deploy&#x2F;supervisord&#x2F;conf&#x2F;项目对应的conf文件</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>cat 文件进行查看 应用的启动配置的配置文件。<h3 id="其实不是不可以使用jmap而是jmap-dump的使用的时候需要注意。有可能会导致服务停止！！"><a href="#其实不是不可以使用jmap而是jmap-dump的使用的时候需要注意。有可能会导致服务停止！！" class="headerlink" title="其实不是不可以使用jmap而是jmap -dump的使用的时候需要注意。有可能会导致服务停止！！"></a>其实不是不可以使用jmap而是jmap -dump的使用的时候需要注意。有可能会导致服务停止！！</h3></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/JVM%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" data-id="cka9w7lh200004k7v74gj1y7s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-请分清楚Java内存区域和Java内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/%E8%AF%B7%E5%88%86%E6%B8%85%E6%A5%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-05-16T17:14:49.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/%E8%AF%B7%E5%88%86%E6%B8%85%E6%A5%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">请分清楚Java内存区域和Java内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>java内存区域是java虚拟机在执行java程序的时候会把它所管理的内存进行划分不同的数据区域</strong>。<br><strong>但是java内存模型是为了屏蔽各种硬件和操作系统的内存访问的差异，已实现java程序在不同的操作系统中都能达到一致的访问效果</strong></p>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><strong>1. 线程共享区</strong>：</p>
<ul>
<li>堆：堆可分为eden区和survior to和survior from 区 刚创建的对象，且堆内存够放下这个对象，都会放在eden区。</li>
<li>方法区： 存储已经被加载的类信息，常量，静态变量，即时编译后的代码等数据。在hotspot虚拟机中方法区也被称为老年代。</li>
</ul>
<p><strong>2. 线程独享区</strong></p>
<ul>
<li>Java虚拟机栈：在我们代码在运行是调用一个方法就会创建一个栈帧用于存储局部变量表，动态链接，操作数栈，方法出口等。调用方法的过程也就是压栈和弹栈的过程，栈的数据结构是先进后出的我们可以想一下主方法调用其他方法，其他方法调用完成那其他的方法就弹栈了谈完后其以及已经将动态链接的数据已经改变，于是你的主方法内的数据也随即改变。仔细品品。</li>
<li>本地方发栈： 本地方法栈和Java虚拟机栈的作用类似，Java虚拟机栈是为java方法的使用而执行的，但是本地方法栈是为了Java虚拟机调用的native方法执行的。正是因为本地方法栈不会限制使用的语言，使用的方法还有数据结构。</li>
<li>程序计数器：粗糙一点也就是为了记录代码执行到那一块了。还有就是我们在执行多线程的时候，在虚拟机中并不是所谓的同步执行的，而是通过线程的切换并分配处理器的时间的方式来实现的，所以在切换的过程中有的线程执行了一半，又切换到了其他线程那就得将其字节码指令执行到那一块就得记录下来，这也是程序计数器为什么是私有的原因。</li>
</ul>
<p><strong>3. 直接内存</strong>（非Java虚拟机中运行时动态区域，但是也会引起OOM）<br><img src="https://img-blog.csdnimg.cn/20200504003454150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MSDffKes-1588523651379)(47A49CD3238948398729B5DD70C4D87F)\]"></p>
<ul>
<li>直接内存并不属于JVM动态运行时区域，我们在使用NIO的时候基于通道与缓冲区的方式（buffer）的I/O的方式，他可以使用native函数库直接分配堆外内存 ，然后通过存储在Java堆种的dirctyByteBuffer对象作为这块堆内存的一面用进行操作。<h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2></li>
</ul>
<ol>
<li>Java的内存模型重要的目标是定义程序中的各个变量的访问规则。即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处变量只是针对全局变量和静态字段，和构成数组的对象元素。</li>
<li>Java的内存模型分为 主内存，工作内存。</li>
</ol>
<ul>
<li>工作内存：每一个线程都拥有自己的工作内存，工作内存保存的是从主内存复制拷贝过来的副本,不同的线程之间是不可以直接进行工作内存的访问，必须通过主内存作为中间人才可以访问。</li>
<li>主内存：主内存就用来存放所有的公共变量。线程间可以共享的变量。</li>
<li>Java内存模型和Java运行时动态内存模型类比的话，那么主内存就是其Java堆中的那些对象实例，而工作内存区域就是Java虚拟机栈中的局部变量表还有refrence所指向的数据，还有方法参数等。<br><img src="https://img-blog.csdnimg.cn/20200504003626339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQxMzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="思考一下"><a href="#思考一下" class="headerlink" title="思考一下"></a>思考一下</h3></li>
</ul>
<p><strong>volatile关键字是如何达到变量在各个线程间是可见的呢？</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/%E8%AF%B7%E5%88%86%E6%B8%85%E6%A5%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-id="cka9w7lhe00014k7vd5c94160" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-微观经济学和宏观经济学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yuanxindong.github.io/2020/05/17/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%92%8C%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/" class="article-date">
  <time datetime="2020-05-16T17:13:36.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/yuanxindong.github.io/2020/05/17/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%92%8C%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/">微观经济学和宏观经济学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是微观经济学？"><a href="#什么是微观经济学？" class="headerlink" title="什么是微观经济学？"></a>什么是微观经济学？</h3><p> 微观经济学又称个体经济学，小经济学，是宏观经济学的对称。微观经济学主要以单个经济单位(单个的生产者、单个的消费者、单个市场的经济活动)作为研究对象，分析单个生产者如何将有限的资源分配在各种商品的生产上以取得最大的利润；单个消费者如何将有限的收入分配在各种商品的消费上以获得最大的满足。同时，</p>
<p> 微观经济学还分析==单个生产者的产量、成本、使用的生产要素数量和利润如何确定==；生产要素供应者的收入如何决定；单个商品的效用、供给量、需求量和价格如何确定等等。</p>
<p>　　微观经济学 ——分析个体经济单位的经济行为,在此基础上,研究现代西方经济社会的市场机制运行及其在经济资源配置中的作用,并提出微观经济政策以纠正市场失灵。</p>
<p>　　微观经济学关心社会中的个人和各组织之间的交换过程，它研究的基本问题是资源配置的决定，其基本理论就是通过供求来决定相对价格的理论。所以微观经济学的主要范围包括消费者选择，厂商进行的供给和收入分配。</p>
<p>　　微观”是希腊文“ μικρο ”的意译，原意是“小”。微观经济学是研究社会中单个经济单位的经济行为，以及相应的经济变量的单项数值如何决定的经济学说。亦称市场经济学或价格理论。微观经济学的中心理论是价格理论。微观经济学的一个中心思想是，自由交换往往使资源得到最充分的利用，在这种情况下，资源配置被认为是帕累托（Pareto） 有效的。<br>　  总结一下：通俗来讲微观经济学就是研究让一个个体或者一个组织来的利益最大化。将其现有资源最大化使用。也就是我们接下来要说的：</p>
<h3 id="微观经济学的研究方向"><a href="#微观经济学的研究方向" class="headerlink" title="微观经济学的研究方向"></a>微观经济学的研究方向</h3><ul>
<li>微观经济学研究市场中个体的经济行为，亦即单个家庭、单个厂商和单个市场的经济行为以及相应的经济变量数值的决定。</li>
<li>==它从资源稀缺这个基本概念出发，认为所有个体的行为准则在于设法利用有限的资源取得最大的收获，并由此来考察个体取得最大收获的条件==。（感觉很适合目前“资源稀缺”的我）</li>
<li>在商品与劳务市场上，作为消费者的家庭根据各种商品的不同价格进行选择，==设法用有限的收入从所购买的各种商品量中获得最大的效用或满足==（这也就是我们平时所说的性价比，让你所买的东西性价比达到最高）。家庭选择商品的行动必然会影响商品的价格，市场价格的变动又是厂商确定生产何种商品的信号。</li>
<li>厂商是各种商品及劳务的供给者，厂商的目的则在于如何用最小的生产成本，生产出最大的产品量，获得取最大限度的利润。厂商的抉择又将影响到生产要素市场上的各项价格，从而影响到家庭的收入。家庭和厂商的抉择均通过市场上的供求关系表现出来，通过价格变动进行协调。因此，微观经济学的任务就是研究==市场机制及其作用，均衡价格的决定，考察市场机制如何通过调节个体行为取得资源最优配置的条件与途径==。微观经济学也就是关于市场机制的经济学，它以价格为分析的中心，因此也称作价格理论。</li>
<li>微观经济学还考察了市场机制失灵时，政府如何采取干预行为与措施的理论基础（就在最近疫情，政府的贷款利率降低，向民众发放优惠券等）。</li>
<li>微观经济学是马歇尔的均衡价格理论基础上，吸收美国经济学家张伯仑和英国经济学家罗宾逊的垄断竞争理论以及其他理论后逐步建立起来的。凯恩斯主义的宏观经济学盛行之后，这种着重研究个体经济行为的传统理论，就被称为微观经济学。<h3 id="微观经济学与宏观经济学的区别"><a href="#微观经济学与宏观经济学的区别" class="headerlink" title="微观经济学与宏观经济学的区别"></a>微观经济学与宏观经济学的区别</h3></li>
<li>了解了微观经济学后，那宏观经济学呢？（已经明确：主要还是学习微观经济学）</li>
</ul>
<p>　　二者的区别主要表现在：</p>
<p>　　（1）==研究对象不同==。微观经济学的研究对象是单个经济单位，如家庭、厂商等。正如美国经济学家J亨德逊（JHenderson）所说居民户和厂商这种单个单位的最优化行为奠定了微观经济学的基础。而宏观经济学的研究对象则是整个经济，研究整个经济的运行方式与规律，从总量上分析经济问题。正如萨缪尔逊所说，宏观经济学是根据产量、收入、价格水平和失业来分析整个经济行为。美国经济学家E夏皮罗（EShapiro）则强调了宏观经济学考察==国民经济作为一个整体的功能==。</p>
<p>　　（2）==解决的问题不同==。==微观经济学要解决的是资源配置问题==，即生产什么、如何生产和为谁生产的问题，以实现个体效益的最大化。宏观经济学则把资源配置作为既定的前提，==研究社会范围内的资源利用问题，以实现社会福利的最大化==。</p>
<p>　　（3）==研究方法不同==。微观经济学的研究方法是个量分析，即研究经济变量的单项数值如何决定。而宏观经济学的研究方法则是总量分析，即对能够反映整个经济运行情况的经济变量的决定、变动及其相互关系进行分析。这些总量包括两类，一类是个量的总和，另一类是平均量。因此，宏观经济学又称为总量经济学。</p>
<p>　　（4）==基本假设不同==。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanxdxindong.github.io/yuanxindong.github.io/2020/05/17/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%92%8C%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/" data-id="cka9w7lhg00034k7vcjc8ey32" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/yuanxindong.github.io/page/2/">2</a><a class="extend next" rel="next" href="/yuanxindong.github.io/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/yuanxindong.github.io/archives/2020/05/">五月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/%E4%BB%A5%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E7%90%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/">以正确姿势理解区块链技术？</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/">个人简历</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/">比特币白皮书</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/">比特币和区块链技术</a>
          </li>
        
          <li>
            <a href="/yuanxindong.github.io/2020/05/17/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">HTTP基础知识</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 yuanxindong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/yuanxindong.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/yuanxindong.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/yuanxindong.github.io/fancybox/jquery.fancybox.css">

  
<script src="/yuanxindong.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/yuanxindong.github.io/js/script.js"></script>




  </div>
</body>
</html>